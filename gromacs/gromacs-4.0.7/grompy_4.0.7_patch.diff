diff -ur -x '^.git' ../gromacs-4.0.7-git//configure.ac ./configure.ac
--- ../gromacs-4.0.7-git//configure.ac	2011-09-18 12:46:10.000000000 +0200
+++ ./configure.ac	2011-09-18 17:51:38.805041060 +0200
@@ -63,6 +63,9 @@
               [AC_HELP_STRING([--enable-mpi],
 	                      [Compile for parallel runs using MPI])],,enable_mpi=no)
 
+AC_ARG_ENABLE(grompy,
+              [AC_HELP_STRING([--enable-grompy],
+	                      [Compile for Grompy])],,enable_grompy=no)
 
 ### MPI environment
 AC_ARG_ENABLE(mpi-environment,
@@ -952,6 +955,7 @@
 AC_SUBST(AS)
 AC_SUBST(INCLUDES)          # should be automatic, but doesnt seem to be?
 AC_SUBST(GMXLIB_LIBOBJS)
+AC_SUBST(MDRUNLIB_LIBOBJS)
 AC_SUBST(MDLIB_LIBOBJS)
 AC_SUBST(GMXANA_LIBOBJS)
 
@@ -966,6 +970,11 @@
 if test "$enable_mpi" = "yes"; then
   LIBSUFFIX="_mpi"
 fi
+
+if test "$enable_grompy" = "yes"; then
+  LIBSUFFIX="_grompy"
+fi
+
 if test "$enable_float" = "no"; then
   LIBSUFFIX="${LIBSUFFIX}_d"
 fi
Bin√§rdateien ../gromacs-4.0.7-git//.git/index and ./.git/index sind verschieden.
diff -ur -x '^.git' ../gromacs-4.0.7-git//include/force.h ./include/force.h
--- ../gromacs-4.0.7-git//include/force.h	2011-09-18 18:17:05.795041497 +0200
+++ ./include/force.h	2011-09-18 12:53:13.195035929 +0200
@@ -93,6 +93,8 @@
 
 extern t_forcerec *mk_forcerec(void);
 
+void clear_forcerec(t_forcerec *fr);
+
 extern t_forcetable make_tables(FILE *fp,const t_forcerec *fr,
 				bool bVerbose,const char *fn,
 				real rtab,bool bForceUser,bool b14only);
@@ -130,6 +132,9 @@
 extern void init_enerdata(FILE *log,int ngener,gmx_enerdata_t *enerd);
 /* Intializes the energy storage struct */
 
+extern void clear_enerdata(gmx_enerdata_t *enerd);
+/* Clears the energy storage struct */
+
 extern void update_forcerec(FILE *fplog,t_forcerec *fr,matrix box);
 /* Updates parameters in the forcerec that are time dependent */
 
diff -ur -x '^.git' ../gromacs-4.0.7-git//include/mdebin.h ./include/mdebin.h
--- ../gromacs-4.0.7-git//include/mdebin.h	2011-09-18 18:17:05.795041497 +0200
+++ ./include/mdebin.h	2011-09-18 12:53:13.205035929 +0200
@@ -92,5 +92,7 @@
 extern void
 restore_energyhistory_from_state(t_mdebin * mdebin,energyhistory_t * enerhist);
 
+extern void clear_mdebin(t_mdebin *mdebin);
+
 #endif	/* _mdebin_h */
 
diff -ur -x '^.git' ../gromacs-4.0.7-git//include/mdrun.h ./include/mdrun.h
--- ../gromacs-4.0.7-git//include/mdrun.h	2011-09-18 18:17:05.805041497 +0200
+++ ./include/mdrun.h	2011-09-18 12:53:13.195035929 +0200
@@ -75,6 +75,27 @@
 #define MD_STARTFROMCPT (1<<18)
 
 
+typedef struct {
+    t_inputrec      *inputrec;
+    t_state         *state;
+    matrix          box;
+    rvec            *buf;
+    rvec            *f;
+    t_nrnb          *nrnb;
+    gmx_mtop_t      *mtop;
+    t_mdatoms       *mdatoms;
+    t_forcerec      *fr;
+    t_fcdata        *fcd;
+    real            ewaldcoeff;
+    gmx_pme_t       *pmedata;
+    gmx_vsite_t     *vsite;
+    gmx_wallcycle_t wcycle;
+    int             nsteps_done;
+    t_mdebin        *mdebin;
+    rvec            *xsave;
+    rvec            *vsave;
+} mdrunner_comm;
+
 enum {
   ddnoSEL, ddnoINTERLEAVE, ddnoPP_PME, ddnoCARTESIAN, ddnoNR
 };
@@ -117,6 +138,28 @@
 extern gmx_integrator_t do_tpi;
 /* Do test particle insertion */
 
+extern time_t do_hybrid(FILE *log,t_commrec *cr,
+                        int nfile,t_filenm fnm[],
+                        bool bVerbose,bool bCompact,
+                        gmx_vsite_t *vsite,gmx_constr_t constr,
+                        int stepout,
+                        t_inputrec *inputrec,
+                        gmx_mtop_t *mtop,t_fcdata *fcd,
+                        t_state *state,rvec f[],
+                        rvec buf[],t_mdatoms *mdatoms,
+                        t_nrnb *nrnb,gmx_wallcycle_t wcycle,
+                        gmx_edsam_t ed, 
+                        t_forcerec *fr,
+                        int repl_ex_nst,int repl_ex_seed,
+                        real cpt_period,real max_hours,
+                        unsigned long Flags,
+                        int *nsteps_done,
+                        t_mdebin **mdbn,
+                        rvec *xsave,
+                        rvec *vsave);
+
+/* Do hybrid MD/MC integration step(s) */
+
 
 /* ROUTINES from sim_util.c */
 extern void do_pbc_first(FILE *log,matrix box,t_forcerec *fr,
@@ -174,6 +217,10 @@
 extern void calc_dispcorr(FILE *fplog,t_inputrec *ir,t_forcerec *fr,int step,
 			  int natoms,matrix box,real lambda,
 			  tensor pres,tensor virial,real ener[]);
+                          
+extern void calc_dispcorr_non_static(FILE *fplog,t_inputrec *ir,t_forcerec *fr,int step,
+                                     int natoms,matrix box,real lambda,
+                                     tensor pres,tensor virial,real ener[]);
      
 
 typedef enum
@@ -190,6 +237,15 @@
 extern void check_nnodes_top(char *fn,t_topology *top);
 /* Reset the tpr file to work with one node if necessary */
 
+extern void clear_state(t_state *state);
+/* Clears the state*/
+
+extern void reset_energy_history(t_state *state);
+/* Resets the state energy history */
+
+extern void reset_kinetic_energy_history(t_state *state);
+/* Resets the state kinetic energy history */
+
 extern void init_single(FILE *log,
                         t_inputrec *inputrec, char *tpbfile, gmx_mtop_t *mtop,
 			t_state *state);
@@ -255,6 +311,46 @@
 		     unsigned long Flags);
 /* Driver routine, that calls the different methods */
 
+extern void mdrunner_read_state(FILE *fplog,
+                                t_commrec *cr,
+                                int nfile,
+                                t_filenm fnm[],
+                                bool bVerbose,
+                                unsigned long Flags,
+                                mdrunner_comm *mc);
+/* Driver routine, that calls the different methods */
+
+extern void mdrunner_initialize_structs(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+                                        bool bVerbose,
+                                        ivec ddxyz,int dd_node_order,real rdd,real rconstr,
+                                        char *dddlb_opt,real dlb_scale,
+                                        char *ddcsx,char *ddcsy,char *ddcsz,
+                                        real pforce,unsigned long Flags,
+                                        mdrunner_comm *mc);
+/* Driver routine, that calls the different methods */
+
+extern void mdrunner_initialize(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+                                bool bVerbose,
+                                ivec ddxyz,int dd_node_order,real rdd,real rconstr,
+                                char *dddlb_opt,real dlb_scale,
+                                char *ddcsx,char *ddcsy,char *ddcsz,
+                                real pforce,unsigned long Flags,
+                                mdrunner_comm *mc);
+/* Driver routine, that calls the different methods */
+
+extern time_t mdrunner_integrate(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+                                 bool bVerbose,bool bCompact,
+                                 real dlb_scale,
+                                 int nstepout,gmx_edsam_t ed,int repl_ex_nst,int repl_ex_seed,
+                                 real cpt_period,real max_hours,unsigned long Flags,
+                                 mdrunner_comm *mc);
+/* Driver routine, that calls the different methods */
+
+extern void mdrunner_finalize(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+                              unsigned long Flags,
+                              time_t start_t,mdrunner_comm *mc);
+/* Driver routine, that calls the different methods */
+                                
 extern void init_md(FILE *fplog,
 		    t_commrec *cr,t_inputrec *ir,real *t,real *t0,
 		    real *lambda,real *lam0,
@@ -269,4 +365,41 @@
 		    bool *bNEMD,bool *bSimAnn,t_vcm **vcm, unsigned long Flags);
 /* Routine in sim_util.c */
      
+extern bool copy_and_add_molecule(mdrunner_comm *mccurrent,
+                                  mdrunner_comm *mctrial,
+                                  int nmolcurrent,
+                                  int nmoltrial,
+                                  rvec *xadd,
+                                  rvec *vadd,
+                                  int *atomtype,
+                                  int natomspertrialmolecule,
+                                  int index_offset,
+                                  real *sigmasatomcrossterms2frac,
+                                  int natomtypes);
+/* copy velocity and coordinate arrays and add one particle */
+
+extern void copy_and_remove_molecule(mdrunner_comm *mccurrent,
+                                     mdrunner_comm *mctrial,
+                                     int nmolcurrent,
+                                     int nmoltrial,
+                                     int imolremove,
+                                     int index_offset,
+                                     int natomspertrialmolecule);
+/* copy velocity and coordinate arrays and remove one particle */
+
+extern void clear_xsave(mdrunner_comm *mc);
+/* clear saved coordinate array */
+
+extern void clear_vsave(mdrunner_comm *mc);
+/* Clear saved velocity array */
+
+extern void copy_saved_coords_and_velocities(mdrunner_comm *mc);
+/* copy saved velocity and coordinate arrays */
+
+extern void swap_coordinate_indices(mdrunner_comm *mc,
+                                    int molblock,
+                                    int curr_mol,
+                                    int trial_mol);
+/* swap velocity and coordinate arrays of input indexes*/
+
 #endif	/* _mdrun_h */
diff -ur -x '^.git' ../gromacs-4.0.7-git//include/mshift.h ./include/mshift.h
--- ../gromacs-4.0.7-git//include/mshift.h	2011-09-18 18:17:05.805041497 +0200
+++ ./include/mshift.h	2011-09-18 12:53:13.205035929 +0200
@@ -53,6 +53,9 @@
  * If bSettle && bShakeOnly the settles are used too.
  */
 
+extern void clear_graph(t_graph *graph);
+/* Clears the graph */
+
 extern void mk_graph_ilist(FILE *fplog,
 			   t_ilist *ilist,int at_start,int at_end,
 			   bool bShakeOnly,bool bSettle,
diff -ur -x '^.git' ../gromacs-4.0.7-git//include/mtop_util.h ./include/mtop_util.h
--- ../gromacs-4.0.7-git//include/mtop_util.h	2011-09-18 18:17:05.805041497 +0200
+++ ./include/mtop_util.h	2011-09-18 12:53:13.205035929 +0200
@@ -210,6 +210,10 @@
 extern gmx_localtop_t *
 gmx_mtop_generate_local_top(gmx_mtop_t *mtop,t_inputrec *ir);
 
+/*
+ *routine for clearing the local top
+ */
+extern void gmx_mtop_clear_local_top(gmx_localtop_t *top);
 
 /* Converts a gmx_mtop_t struct to t_topology.
  * All memory relating only to mtop will be freed.
diff -ur -x '^.git' ../gromacs-4.0.7-git//include/types/constr.h ./include/types/constr.h
--- ../gromacs-4.0.7-git//include/types/constr.h	2011-09-18 18:17:05.805041497 +0200
+++ ./include/types/constr.h	2011-09-18 12:53:13.195035929 +0200
@@ -49,4 +49,7 @@
 /* Abstract type for essential dynamics that is defined only in edsam.c */
 typedef struct gmx_edsam *gmx_edsam_t;
 
+extern void clear_constr(gmx_constr_t constr);
+/* Clears the constr struct */
+
 #endif
diff -ur -x '^.git' ../gromacs-4.0.7-git//include/update.h ./include/update.h
--- ../gromacs-4.0.7-git//include/update.h	2011-09-18 18:17:05.815041497 +0200
+++ ./include/update.h	2011-09-18 12:53:13.205035929 +0200
@@ -55,6 +55,9 @@
 /* Initialize the stochastic dynamics struct */
 extern gmx_stochd_t init_stochd(FILE *fplog,t_inputrec *ir);
 
+extern void clear_sd(gmx_stochd_t sd,t_inputrec *ir);
+/* Clear the sd strcut*/
+
 /* Store the random state from sd in state */
 extern void get_stochd_state(gmx_stochd_t sd,t_state *state);
 
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/gmxlib/mshift.c ./src/gmxlib/mshift.c
--- ../gromacs-4.0.7-git//src/gmxlib/mshift.c	2011-09-18 18:17:05.815041497 +0200
+++ ./src/gmxlib/mshift.c	2011-09-18 12:53:13.095035929 +0200
@@ -298,6 +298,22 @@
   return bMultiPart;
 }
 
+void clear_graph(t_graph *graph)
+{
+  int i;
+  
+  for(i=0;i<graph->nnodes;i++)
+  {
+      sfree(graph->edge[i]);
+  }
+  
+  sfree(graph->edge);
+  sfree(graph->nedge);
+  sfree(graph->ishift);
+  sfree(graph->egc);
+  sfree(graph);
+}
+
 void mk_graph_ilist(FILE *fplog,
 		    t_ilist *ilist,int at_start,int at_end,
 		    bool bShakeOnly,bool bSettle,
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/gmxlib/mtop_util.c ./src/gmxlib/mtop_util.c
--- ../gromacs-4.0.7-git//src/gmxlib/mtop_util.c	2011-09-18 18:17:05.815041497 +0200
+++ ./src/gmxlib/mtop_util.c	2011-09-18 12:53:13.095035929 +0200
@@ -540,7 +540,7 @@
                      int dnum,int snum)
 {
     int i,j,l,nra,size;
-    
+
     if (src->nr)
     {
         size=(dest->nr+copies*src->nr+1);
@@ -750,6 +750,24 @@
     return top;
 }
 
+void gmx_mtop_clear_local_top(gmx_localtop_t *top)
+{
+    int i;
+
+    sfree(top->cgs.index);
+    sfree(top->excls.index);
+    sfree(top->excls.a);
+////////////////////////////////    
+//  MIGHT CAUSE PROBLEMS IN MARTINI MODE...
+    for(i=0;i<F_NRE;i++)
+    {
+        sfree(top->idef.il[i].iatoms);
+    }
+////////////////////////////////
+    sfree(top);
+    top = NULL;
+}
+
 t_topology gmx_mtop_t_to_t_topology(gmx_mtop_t *mtop)
 {
     int mt,mb;
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/gmxlib/nonbonded/nb_kernel_ia32_3dnow/nb_kernel_ia32_3dnow.c ./src/gmxlib/nonbonded/nb_kernel_ia32_3dnow/nb_kernel_ia32_3dnow.c
--- ../gromacs-4.0.7-git//src/gmxlib/nonbonded/nb_kernel_ia32_3dnow/nb_kernel_ia32_3dnow.c	2011-09-18 18:17:05.815041497 +0200
+++ ./src/gmxlib/nonbonded/nb_kernel_ia32_3dnow/nb_kernel_ia32_3dnow.c	2011-09-18 12:53:13.075035929 +0200
@@ -173,8 +173,10 @@
     
     if(log)
         fprintf(log,"Testing AMD 3DNow support...");
-
-	nb_kernel_ia32_3dnow_present = TRUE;
+    
+//      quick hack: I don't know how to avoid the ignoring of signal when called multiple times...
+// 	nb_kernel_ia32_3dnow_present = TRUE;
+        nb_kernel_ia32_3dnow_present = FALSE;
 	signal(SIGILL,nb_kernel_ia32_3dnow_sigill_handler);
 
 	/* return to this point after executing the signal handler
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/kernel/Makefile.am ./src/kernel/Makefile.am
--- ../gromacs-4.0.7-git//src/kernel/Makefile.am	2011-09-18 12:46:10.000000000 +0200
+++ ./src/kernel/Makefile.am	2011-09-18 13:33:41.635036625 +0200
@@ -6,8 +6,10 @@
 
 noinst_LTLIBRARIES  = libgmxpreprocess@LIBSUFFIX@.la
 
+
 LDADD = $(noinst_LTLIBRARIES) ../mdlib/libmd@LIBSUFFIX@.la ../gmxlib/libgmx@LIBSUFFIX@.la 
 
+
 libgmxpreprocess@LIBSUFFIX@_la_LIBADD       =
 libgmxpreprocess@LIBSUFFIX@_la_DEPENDENCIES =
 
@@ -43,6 +45,20 @@
 vsite_parm.c	vsite_parm.h	\
 xlate.c		xlate.h	
 
+libmdrun@LIBSUFFIX@_la_LIBADD         = @MDRUNLIB_LIBOBJS@ ../gmxlib/libgmx@LIBSUFFIX@.la ../mdlib/libmd@LIBSUFFIX@.la
+libmdrun@LIBSUFFIX@_la_DEPENDENCIES   = @MDRUNLIB_LIBOBJS@ ../gmxlib/libgmx@LIBSUFFIX@.la ../mdlib/libmd@LIBSUFFIX@.la
+libmdrun@LIBSUFFIX@_la_LDFLAGS        = -version-info @SHARED_VERSION_INFO@
+lib_LTLIBRARIES = libmdrun@LIBSUFFIX@.la
+
+libmdrun@LIBSUFFIX@_la_SOURCES = \
+compute_io.c 	compute_io.h	\
+glaasje.c 	glaasje.h 	\
+gctio.c 	ionize.c	ionize.h 	xmdrun.h\
+do_gct.c 	repl_ex.c 	repl_ex.h\
+xutils.c 	md.c 		\
+mdrun.c 	genalg.c	genalg.h
+
+
 bin_PROGRAMS = \
 	grompp		mdrun		tpbconv	  	pdb2gmx		\
 	protonate	luck		gmxdump				\
@@ -68,7 +84,7 @@
 	do_gct.c 	repl_ex.c	repl_ex.h	\
 	xutils.c	md.c		mdrun.c		\
 	genalg.c	genalg.h
-
+mdrun_CFLAGS = $(AM_CFLAGS)
 # shortcut to install only mdrun
 
 install-mdrun: mdrun$(EXEEXT)
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/kernel/md.c ./src/kernel/md.c
--- ../gromacs-4.0.7-git//src/kernel/md.c	2011-09-18 18:17:05.845041497 +0200
+++ ./src/kernel/md.c	2011-09-18 12:53:13.025035929 +0200
@@ -111,40 +111,303 @@
 /* The array should match the eI array in include/types/enums.h */
 const gmx_intp_t integrator[eiNR] = { {do_md}, {do_steep}, {do_cg}, {do_md}, {do_md}, {do_nm}, {do_lbfgs}, {do_tpi}, {do_tpi}, {do_md} };
 
-void mdrunner(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
-	      bool bVerbose,bool bCompact,
-	      ivec ddxyz,int dd_node_order,real rdd,real rconstr,
-	      char *dddlb_opt,real dlb_scale,
-	      char *ddcsx,char *ddcsy,char *ddcsz,
-	      int nstepout,gmx_edsam_t ed,int repl_ex_nst,int repl_ex_seed,
-	      real pforce,real cpt_period,real max_hours,
-	      unsigned long Flags)
+void mdrunner_read_state(FILE *fplog,
+                         t_commrec *cr,
+                         int nfile,
+                         t_filenm fnm[],
+                         bool bVerbose,
+                         unsigned long Flags,
+                         mdrunner_comm *mc)
+{
+  int list;
+  
+  snew(mc->inputrec,1);
+  snew(mc->mtop,1);
+        
+  if (bVerbose && SIMMASTER(cr)) 
+    fprintf(stderr,"Getting Loaded...\n");
+  
+  if (Flags & MD_APPENDFILES) 
+  {
+          fplog = NULL;
+  }
+        
+  if (PAR(cr)) {
+    /* The master thread on the master node reads from disk, 
+     * then distributes everything to the other processors.
+     */
+        
+    list = (SIMMASTER(cr) && !(Flags & MD_APPENDFILES)) ?  (LIST_SCALARS | LIST_INPUTREC) : 0;
+                  
+    snew(mc->state,1);
+    init_parallel(fplog,ftp2fn(efTPX,nfile,fnm),cr,
+                  mc->inputrec,mc->mtop,mc->state,list);
+          
+  } else {
+    /* Read a file for a single processor */
+    snew(mc->state,1);
+    init_single(fplog,mc->inputrec,ftp2fn(efTPX,nfile,fnm),mc->mtop,mc->state);
+  }
+}
+
+void mdrunner_initialize_structs(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+                                 bool bVerbose,
+                                 ivec ddxyz,int dd_node_order,real rdd,real rconstr,
+                                 char *dddlb_opt,real dlb_scale,
+                                 char *ddcsx,char *ddcsy,char *ddcsz,
+                                 real pforce,unsigned long Flags,
+                                 mdrunner_comm *mc)
+{
+  int        i,m,nChargePerturbed=-1,status,nalloc;
+  char       *gro;
+  bool       bReadRNG,bReadEkin;
+  
+  /* NMR restraints must be initialized before load_checkpoint,
+   * since with time averaging the history is added to t_state.
+   * For proper consistency check we therefore need to extend
+   * t_state here.
+   * So the PME-only nodes (if present) will also initialize
+   * the distance restraints.
+   */
+  snew(mc->fcd,1);
+
+  /* This needs to be called before read_checkpoint to extend the state */
+  init_disres(fplog,mc->mtop,mc->inputrec,cr,Flags & MD_PARTDEC,mc->fcd,mc->state);
+                                          
+  if (gmx_mtop_ftype_count(mc->mtop,F_ORIRES) > 0) {
+    if (PAR(cr) && !(Flags & MD_PARTDEC)) {
+      gmx_fatal(FARGS,"Orientation restraints do not work (yet) with domain decomposition, use particle decomposition (mdrun option -pd)");
+    }
+    /* Orientation restraints */
+    if (MASTER(cr)) {
+      init_orires(fplog,mc->mtop,mc->state->x,mc->inputrec,cr->ms,&(mc->fcd->orires),mc->state);
+    }
+  }
+  
+  if (DEFORM(*(mc->inputrec))) {
+    /* Store the deform reference box before reading the checkpoint */
+    if (SIMMASTER(cr)) {
+      copy_mat(mc->state->box,mc->box);
+    }
+    if (PAR(cr)) {
+      gmx_bcast(sizeof(mc->box),mc->box,cr);
+    }
+    set_deform_reference_box(mc->inputrec->init_step,mc->box);
+  }
+
+  if (opt2bSet("-cpi",nfile,fnm)) 
+  {
+      /* Check if checkpoint file exists before doing continuation.
+       * This way we can use identical input options for the first and subsequent runs...
+       */
+      if( fexist(opt2fn("-cpi",nfile,fnm)) )
+      {
+          load_checkpoint(opt2fn("-cpi",nfile,fnm),fplog,
+                          cr,Flags & MD_PARTDEC,ddxyz,
+                          mc->inputrec,mc->state,&bReadRNG,&bReadEkin,
+                          (Flags & MD_APPENDFILES));
+          
+          if (bReadRNG)
+          {
+              Flags |= MD_READ_RNG;
+          }
+          if (bReadEkin)
+          {
+              Flags |= MD_READ_EKIN;
+          }
+      }
+  }
+  
+  if (MASTER(cr) && (Flags & MD_APPENDFILES))
+  {
+      fplog = gmx_log_open(ftp2fn(efLOG,nfile,fnm),cr, !(Flags & MD_SEPPOT) ,Flags);
+  }
+  
+  if (SIMMASTER(cr)) 
+  {
+      copy_mat(mc->state->box,mc->box);
+  }
+        
+  if (PAR(cr)) 
+  {
+      gmx_bcast(sizeof(mc->box),mc->box,cr);
+  }
+        
+  if (bVerbose && SIMMASTER(cr))
+    fprintf(stderr,"Loaded with Money\n\n");
+
+  if (PAR(cr) && !((Flags & MD_PARTDEC) || EI_TPI(mc->inputrec->eI))) {
+    cr->dd = init_domain_decomposition(fplog,cr,Flags,ddxyz,rdd,rconstr,
+                                       dddlb_opt,dlb_scale,
+                                       ddcsx,ddcsy,ddcsz,
+                                       mc->mtop,mc->inputrec,
+                                       mc->box,mc->state->x);
+    
+    make_dd_communicators(fplog,cr,dd_node_order);
+
+    /* Set overallocation to avoid frequent reallocation of arrays */
+    set_over_alloc_dd(TRUE);
+  } else {
+    cr->duty = (DUTY_PP | DUTY_PME);
+
+    if (mc->inputrec->ePBC == epbcSCREW)
+      gmx_fatal(FARGS,"pbc=%s is only implemented with domain decomposition",
+                epbc_names[mc->inputrec->ePBC]);
+  }
+
+  if (PAR(cr)) {
+    /* After possible communicator splitting in make_dd_communicators.
+     * we can set up the intra/inter node communication.
+     */
+    gmx_setup_nodecomm(fplog,cr);
+  }
+        
+  mc->wcycle = wallcycle_init(fplog,cr);
+
+  snew(mc->nrnb,1);
+  if (cr->duty & DUTY_PP) {
+    /* For domain decomposition we allocate dynamically
+     * in dd_partition_system.
+     */
+    if (DOMAINDECOMP(cr)) {
+      bcast_state_setup(cr,mc->state);
+    } else {
+      if (PAR(cr)) {
+        if (!MASTER(cr)) {
+          snew(mc->state,1);
+        }
+        bcast_state(cr,mc->state,TRUE);
+      }
+
+      snew(mc->buf,mc->mtop->natoms);
+      snew(mc->f,mc->mtop->natoms);
+    }
+    
+    /* Dihedral Restraints */
+    if (gmx_mtop_ftype_count(mc->mtop,F_DIHRES) > 0) {
+      init_dihres(fplog,mc->mtop,mc->inputrec,mc->fcd);
+    }
+    
+    /* Initiate forcerecord */
+    mc->fr = mk_forcerec();
+    init_forcerec(fplog,mc->fr,mc->fcd,mc->inputrec,mc->mtop,cr,mc->box,FALSE,
+                  opt2fn("-table",nfile,fnm),opt2fn("-tablep",nfile,fnm),
+                  opt2fn("-tableb",nfile,fnm),FALSE,pforce);
+    mc->fr->bSepDVDL = ((Flags & MD_SEPPOT) == MD_SEPPOT);
+    
+    /* Initialize QM-MM */
+    if(mc->fr->bQMMM)
+      init_QMMMrec(cr,mc->box,mc->mtop,mc->inputrec,mc->fr);
+    
+    /* Initialize the mdatoms structure.
+     * mdatoms is not filled with atom data,
+     * as this can not be done now with domain decomposition.
+     */
+    mc->mdatoms = init_mdatoms(fplog,mc->mtop,mc->inputrec->efep!=efepNO);
+    
+    /* Initialize the virtual site communication */
+    mc->vsite = init_vsite(mc->mtop,cr);
+
+    calc_shifts(mc->box,mc->fr->shift_vec);
+
+    /* With periodic molecules the charge groups should be whole at start up
+     * and the virtual sites should not be far from their proper positions.
+     */
+    if (!mc->inputrec->bContinuation && MASTER(cr) &&
+        !(mc->inputrec->ePBC != epbcNONE && mc->inputrec->bPeriodicMols)) {
+      /* Make molecules whole at start of run */
+      if (mc->fr->ePBC != epbcNONE)  {
+        do_pbc_first_mtop(fplog,mc->inputrec->ePBC,mc->box,mc->mtop,mc->state->x);
+      }
+      if (mc->vsite) {
+        /* Correct initial vsite positions are required
+         * for the initial distribution in the domain decomposition
+         * and for the initial shell prediction.
+         */
+        construct_vsites_mtop(fplog,mc->vsite,mc->mtop,mc->state->x);
+      }
+    }
+          
+    /* Initiate PPPM if necessary */
+    if (mc->fr->eeltype == eelPPPM) {
+      if (mc->mdatoms->nChargePerturbed)
+        gmx_fatal(FARGS,"Free energy with %s is not implemented",
+                  eel_names[mc->fr->eeltype]);
+      status = gmx_pppm_init(fplog,cr,FALSE,TRUE,mc->box,
+                             getenv("GMXGHAT"),mc->inputrec, (Flags & MD_REPRODUCIBLE));
+      if (status != 0)
+        gmx_fatal(FARGS,"Error %d initializing PPPM",status);
+    }
+
+    if (EEL_PME(mc->fr->eeltype)) {
+      mc->ewaldcoeff = mc->fr->ewaldcoeff;
+      mc->pmedata = &mc->fr->pmedata;
+    } else {
+      mc->pmedata = NULL;
+    }
+  } else {
+    /* This is a PME only node */
+    
+    /* We don't need the state */
+    done_state(mc->state);
+
+    mc->ewaldcoeff = calc_ewaldcoeff(mc->inputrec->rcoulomb, mc->inputrec->ewald_rtol);
+    snew(mc->pmedata,1);
+  }
+
+  /* Initiate PME if necessary,
+   * either on all nodes or on dedicated PME nodes only. */
+  if (EEL_PME(mc->inputrec->coulombtype)) {
+    if (mc->mdatoms) {
+      nChargePerturbed = mc->mdatoms->nChargePerturbed;
+    }
+    if (cr->npmenodes > 0) {
+      /* The PME only nodes need to know nChargePerturbed */
+      gmx_bcast_sim(sizeof(nChargePerturbed),&nChargePerturbed,cr);
+    }
+    if (cr->duty & DUTY_PME) {
+      status = gmx_pme_init(mc->pmedata,cr,mc->inputrec,
+                            mc->mtop ? mc->mtop->natoms : 0,nChargePerturbed,
+                            (Flags & MD_REPRODUCIBLE));
+      if (status != 0)
+        gmx_fatal(FARGS,"Error %d initializing PME",status);
+    }
+  }
+  
+  if (integrator[mc->inputrec->eI].func == do_md) {
+    /* Turn on signal handling on all nodes */
+    /*
+     * (A user signal from the PME nodes (if any)
+     * is communicated to the PP nodes.
+     */
+    if (getenv("GMX_NO_TERM") == NULL) {
+      if (debug)
+        fprintf(debug,"Installing signal handler for SIGTERM\n");
+      signal(SIGTERM,signal_handler);
+    }
+    if (getenv("GMX_NO_USR1") == NULL) {
+      if (debug)
+        fprintf(debug,"Installing signal handler for SIGUSR1\n");
+      signal(SIGUSR1,signal_handler);
+    }
+  }
+}
+
+void mdrunner_initialize(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+			 bool bVerbose,
+			 ivec ddxyz,int dd_node_order,real rdd,real rconstr,
+			 char *dddlb_opt,real dlb_scale,
+			 char *ddcsx,char *ddcsy,char *ddcsz,
+			 real pforce,unsigned long Flags,
+			 mdrunner_comm *mc)
 {
-  double     nodetime=0,realtime;
-  t_inputrec *inputrec;
-  t_state    *state=NULL;
-  matrix     box;
-  rvec       *buf=NULL,*f=NULL;
-  real       tmpr1,tmpr2;
-  t_nrnb     *nrnb;
-  gmx_mtop_t *mtop=NULL;
-  t_mdatoms  *mdatoms=NULL;
-  t_forcerec *fr=NULL;
-  t_fcdata   *fcd=NULL;
-  real       ewaldcoeff=0;
-  gmx_pme_t  *pmedata=NULL;
-  time_t     start_t=0;
-  gmx_vsite_t *vsite=NULL;
-  gmx_constr_t constr;
   int        i,m,nChargePerturbed=-1,status,nalloc;
   char       *gro;
-  gmx_wallcycle_t wcycle;
   bool       bReadRNG,bReadEkin;
   int        list;
-  int        nsteps_done;
-	
-  snew(inputrec,1);
-  snew(mtop,1);
+  
+  snew(mc->inputrec,1);
+  snew(mc->mtop,1);
   	
   if (bVerbose && SIMMASTER(cr)) 
     fprintf(stderr,"Getting Loaded...\n");
@@ -161,16 +424,17 @@
 	
     list = (SIMMASTER(cr) && !(Flags & MD_APPENDFILES)) ?  (LIST_SCALARS | LIST_INPUTREC) : 0;
 		  
-    snew(state,1);
+    snew(mc->state,1);
     init_parallel(fplog,ftp2fn(efTPX,nfile,fnm),cr,
-		  inputrec,mtop,state,list);
+		  mc->inputrec,mc->mtop,mc->state,list);
 	  
   } else {
     /* Read a file for a single processor */
-    snew(state,1);
-    init_single(fplog,inputrec,ftp2fn(efTPX,nfile,fnm),mtop,state);
+    snew(mc->state,1);
+    init_single(fplog,mc->inputrec,ftp2fn(efTPX,nfile,fnm),mc->mtop,mc->state);
   }
-  if (!EEL_PME(inputrec->coulombtype) || (Flags & MD_PARTDEC)) {
+
+  if (!EEL_PME(mc->inputrec->coulombtype) || (Flags & MD_PARTDEC)) {
     cr->npmenodes = 0;
   }
   
@@ -181,30 +445,30 @@
    * So the PME-only nodes (if present) will also initialize
    * the distance restraints.
    */
-  snew(fcd,1);
+  snew(mc->fcd,1);
 
   /* This needs to be called before read_checkpoint to extend the state */
-  init_disres(fplog,mtop,inputrec,cr,Flags & MD_PARTDEC,fcd,state);
+  init_disres(fplog,mc->mtop,mc->inputrec,cr,Flags & MD_PARTDEC,mc->fcd,mc->state);
 					  
-  if (gmx_mtop_ftype_count(mtop,F_ORIRES) > 0) {
+  if (gmx_mtop_ftype_count(mc->mtop,F_ORIRES) > 0) {
     if (PAR(cr) && !(Flags & MD_PARTDEC)) {
       gmx_fatal(FARGS,"Orientation restraints do not work (yet) with domain decomposition, use particle decomposition (mdrun option -pd)");
     }
     /* Orientation restraints */
     if (MASTER(cr)) {
-      init_orires(fplog,mtop,state->x,inputrec,cr->ms,&(fcd->orires),state);
+      init_orires(fplog,mc->mtop,mc->state->x,mc->inputrec,cr->ms,&(mc->fcd->orires),mc->state);
     }
   }
   
-  if (DEFORM(*inputrec)) {
+  if (DEFORM(*(mc->inputrec))) {
     /* Store the deform reference box before reading the checkpoint */
     if (SIMMASTER(cr)) {
-      copy_mat(state->box,box);
+      copy_mat(mc->state->box,mc->box);
     }
     if (PAR(cr)) {
-      gmx_bcast(sizeof(box),box,cr);
+      gmx_bcast(sizeof(mc->box),mc->box,cr);
     }
-    set_deform_reference_box(inputrec->init_step,box);
+    set_deform_reference_box(mc->inputrec->init_step,mc->box);
   }
 
   if (opt2bSet("-cpi",nfile,fnm)) 
@@ -216,7 +480,7 @@
       {
 	  load_checkpoint(opt2fn("-cpi",nfile,fnm),fplog,
 			  cr,Flags & MD_PARTDEC,ddxyz,
-			  inputrec,state,&bReadRNG,&bReadEkin,
+			  mc->inputrec,mc->state,&bReadRNG,&bReadEkin,
 			  (Flags & MD_APPENDFILES));
 	  
 	  if (bReadRNG)
@@ -237,23 +501,23 @@
   
   if (SIMMASTER(cr)) 
   {
-      copy_mat(state->box,box);
+      copy_mat(mc->state->box,mc->box);
   }
 	
   if (PAR(cr)) 
   {
-      gmx_bcast(sizeof(box),box,cr);
+      gmx_bcast(sizeof(mc->box),mc->box,cr);
   }
 	
   if (bVerbose && SIMMASTER(cr))
     fprintf(stderr,"Loaded with Money\n\n");
 
-  if (PAR(cr) && !((Flags & MD_PARTDEC) || EI_TPI(inputrec->eI))) {
+  if (PAR(cr) && !((Flags & MD_PARTDEC) || EI_TPI(mc->inputrec->eI))) {
     cr->dd = init_domain_decomposition(fplog,cr,Flags,ddxyz,rdd,rconstr,
 				       dddlb_opt,dlb_scale,
 				       ddcsx,ddcsy,ddcsz,
-				       mtop,inputrec,
-				       box,state->x);
+				       mc->mtop,mc->inputrec,
+				       mc->box,mc->state->x);
     
     make_dd_communicators(fplog,cr,dd_node_order);
 
@@ -262,9 +526,9 @@
   } else {
     cr->duty = (DUTY_PP | DUTY_PME);
 
-    if (inputrec->ePBC == epbcSCREW)
+    if (mc->inputrec->ePBC == epbcSCREW)
       gmx_fatal(FARGS,"pbc=%s is only implemented with domain decomposition",
-		epbc_names[inputrec->ePBC]);
+		epbc_names[mc->inputrec->ePBC]);
   }
 
   if (PAR(cr)) {
@@ -274,119 +538,119 @@
     gmx_setup_nodecomm(fplog,cr);
   }
 	
-  wcycle = wallcycle_init(fplog,cr);
+  mc->wcycle = wallcycle_init(fplog,cr);
 
-  snew(nrnb,1);
+  snew(mc->nrnb,1);
   if (cr->duty & DUTY_PP) {
     /* For domain decomposition we allocate dynamically
      * in dd_partition_system.
      */
     if (DOMAINDECOMP(cr)) {
-      bcast_state_setup(cr,state);
+      bcast_state_setup(cr,mc->state);
     } else {
       if (PAR(cr)) {
 	if (!MASTER(cr)) {
-	  snew(state,1);
+	  snew(mc->state,1);
 	}
-	bcast_state(cr,state,TRUE);
+	bcast_state(cr,mc->state,TRUE);
       }
 
-      snew(buf,mtop->natoms);
-      snew(f,mtop->natoms);
+      snew(mc->buf,mc->mtop->natoms);
+      snew(mc->f,mc->mtop->natoms);
     }
     
     /* Dihedral Restraints */
-    if (gmx_mtop_ftype_count(mtop,F_DIHRES) > 0) {
-      init_dihres(fplog,mtop,inputrec,fcd);
+    if (gmx_mtop_ftype_count(mc->mtop,F_DIHRES) > 0) {
+      init_dihres(fplog,mc->mtop,mc->inputrec,mc->fcd);
     }
     
     /* Initiate forcerecord */
-    fr = mk_forcerec();
-    init_forcerec(fplog,fr,fcd,inputrec,mtop,cr,box,FALSE,
+    mc->fr = mk_forcerec();
+    init_forcerec(fplog,mc->fr,mc->fcd,mc->inputrec,mc->mtop,cr,mc->box,FALSE,
 		  opt2fn("-table",nfile,fnm),opt2fn("-tablep",nfile,fnm),
 		  opt2fn("-tableb",nfile,fnm),FALSE,pforce);
-    fr->bSepDVDL = ((Flags & MD_SEPPOT) == MD_SEPPOT);
+    mc->fr->bSepDVDL = ((Flags & MD_SEPPOT) == MD_SEPPOT);
     
     /* Initialize QM-MM */
-    if(fr->bQMMM)
-      init_QMMMrec(cr,box,mtop,inputrec,fr);
+    if(mc->fr->bQMMM)
+      init_QMMMrec(cr,mc->box,mc->mtop,mc->inputrec,mc->fr);
     
     /* Initialize the mdatoms structure.
      * mdatoms is not filled with atom data,
      * as this can not be done now with domain decomposition.
      */
-    mdatoms = init_mdatoms(fplog,mtop,inputrec->efep!=efepNO);
+    mc->mdatoms = init_mdatoms(fplog,mc->mtop,mc->inputrec->efep!=efepNO);
     
     /* Initialize the virtual site communication */
-    vsite = init_vsite(mtop,cr);
+    mc->vsite = init_vsite(mc->mtop,cr);
 
-    calc_shifts(box,fr->shift_vec);
+    calc_shifts(mc->box,mc->fr->shift_vec);
 
     /* With periodic molecules the charge groups should be whole at start up
      * and the virtual sites should not be far from their proper positions.
      */
-    if (!inputrec->bContinuation && MASTER(cr) &&
-	!(inputrec->ePBC != epbcNONE && inputrec->bPeriodicMols)) {
+    if (!mc->inputrec->bContinuation && MASTER(cr) &&
+	!(mc->inputrec->ePBC != epbcNONE && mc->inputrec->bPeriodicMols)) {
       /* Make molecules whole at start of run */
-      if (fr->ePBC != epbcNONE)  {
-	do_pbc_first_mtop(fplog,inputrec->ePBC,box,mtop,state->x);
+      if (mc->fr->ePBC != epbcNONE)  {
+	do_pbc_first_mtop(fplog,mc->inputrec->ePBC,mc->box,mc->mtop,mc->state->x);
       }
-      if (vsite) {
+      if (mc->vsite) {
 	/* Correct initial vsite positions are required
 	 * for the initial distribution in the domain decomposition
 	 * and for the initial shell prediction.
 	 */
-	construct_vsites_mtop(fplog,vsite,mtop,state->x);
+	construct_vsites_mtop(fplog,mc->vsite,mc->mtop,mc->state->x);
       }
     }
 	  
     /* Initiate PPPM if necessary */
-    if (fr->eeltype == eelPPPM) {
-      if (mdatoms->nChargePerturbed)
+    if (mc->fr->eeltype == eelPPPM) {
+      if (mc->mdatoms->nChargePerturbed)
 	gmx_fatal(FARGS,"Free energy with %s is not implemented",
-		  eel_names[fr->eeltype]);
-      status = gmx_pppm_init(fplog,cr,FALSE,TRUE,box,
-			     getenv("GMXGHAT"),inputrec, (Flags & MD_REPRODUCIBLE));
+		  eel_names[mc->fr->eeltype]);
+      status = gmx_pppm_init(fplog,cr,FALSE,TRUE,mc->box,
+			     getenv("GMXGHAT"),mc->inputrec, (Flags & MD_REPRODUCIBLE));
       if (status != 0)
 	gmx_fatal(FARGS,"Error %d initializing PPPM",status);
     }
 
-    if (EEL_PME(fr->eeltype)) {
-      ewaldcoeff = fr->ewaldcoeff;
-      pmedata = &fr->pmedata;
+    if (EEL_PME(mc->fr->eeltype)) {
+      mc->ewaldcoeff = mc->fr->ewaldcoeff;
+      mc->pmedata = &mc->fr->pmedata;
     } else {
-      pmedata = NULL;
+      mc->pmedata = NULL;
     }
   } else {
     /* This is a PME only node */
     
     /* We don't need the state */
-    done_state(state);
+    done_state(mc->state);
 
-    ewaldcoeff = calc_ewaldcoeff(inputrec->rcoulomb, inputrec->ewald_rtol);
-    snew(pmedata,1);
+    mc->ewaldcoeff = calc_ewaldcoeff(mc->inputrec->rcoulomb, mc->inputrec->ewald_rtol);
+    snew(mc->pmedata,1);
   }
 
   /* Initiate PME if necessary,
    * either on all nodes or on dedicated PME nodes only. */
-  if (EEL_PME(inputrec->coulombtype)) {
-    if (mdatoms) {
-      nChargePerturbed = mdatoms->nChargePerturbed;
+  if (EEL_PME(mc->inputrec->coulombtype)) {
+    if (mc->mdatoms) {
+      nChargePerturbed = mc->mdatoms->nChargePerturbed;
     }
     if (cr->npmenodes > 0) {
       /* The PME only nodes need to know nChargePerturbed */
       gmx_bcast_sim(sizeof(nChargePerturbed),&nChargePerturbed,cr);
     }
     if (cr->duty & DUTY_PME) {
-      status = gmx_pme_init(pmedata,cr,inputrec,
-			    mtop ? mtop->natoms : 0,nChargePerturbed,
+      status = gmx_pme_init(mc->pmedata,cr,mc->inputrec,
+			    mc->mtop ? mc->mtop->natoms : 0,nChargePerturbed,
 			    (Flags & MD_REPRODUCIBLE));
       if (status != 0)
 	gmx_fatal(FARGS,"Error %d initializing PME",status);
     }
   }
   
-  if (integrator[inputrec->eI].func == do_md) {
+  if (integrator[mc->inputrec->eI].func == do_md) {
     /* Turn on signal handling on all nodes */
     /*
      * (A user signal from the PME nodes (if any)
@@ -403,86 +667,1679 @@
       signal(SIGUSR1,signal_handler);
     }
   }
+}
 
+time_t mdrunner_integrate(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+			  bool bVerbose,bool bCompact,
+			  real dlb_scale,
+			  int nstepout,gmx_edsam_t ed,int repl_ex_nst,int repl_ex_seed,
+			  real cpt_period,real max_hours,unsigned long Flags,
+			  mdrunner_comm *mc)
+{
+  gmx_constr_t constr;
+  time_t       start_t=0;
+  int          nsteps_done;
+  int          i;
+  
   if (cr->duty & DUTY_PP) {
-    if (inputrec->ePull != epullNO) {
+    if (mc->inputrec->ePull != epullNO) {
       /* Initialize pull code */
-      init_pull(fplog,inputrec,nfile,fnm,mtop,cr,
-		EI_DYNAMICS(inputrec->eI) && MASTER(cr),Flags);
+      init_pull(fplog,mc->inputrec,nfile,fnm,mc->mtop,cr,
+		EI_DYNAMICS(mc->inputrec->eI) && MASTER(cr),Flags);
     }
 
-    constr = init_constraints(fplog,mtop,inputrec,ed,state,cr);
-
+    constr = init_constraints(fplog,mc->mtop,mc->inputrec,ed,mc->state,cr);
+    
     if (DOMAINDECOMP(cr)) {
-      dd_init_bondeds(fplog,cr->dd,mtop,vsite,constr,inputrec,
-		      Flags & MD_DDBONDCHECK,fr->cginfo_global);
+      dd_init_bondeds(fplog,cr->dd,mc->mtop,mc->vsite,constr,mc->inputrec,
+		      Flags & MD_DDBONDCHECK,mc->fr->cginfo_global);
 
-      set_dd_parameters(fplog,cr->dd,dlb_scale,inputrec,fr,box);
+      set_dd_parameters(fplog,cr->dd,dlb_scale,mc->inputrec,mc->fr,mc->box);
      
       setup_dd_grid(fplog,cr->dd);
     }
-
     /* Now do whatever the user wants us to do (how flexible...) */
-    start_t = integrator[inputrec->eI].func(fplog,cr,nfile,fnm,
-					    bVerbose,bCompact,
-					    vsite,constr,
-					    nstepout,inputrec,mtop,
-					    fcd,state,f,buf,
-					    mdatoms,nrnb,wcycle,ed,fr,
-					    repl_ex_nst,repl_ex_seed,
-					    cpt_period,max_hours,
-					    Flags,
-					    &nsteps_done);
-
-    if (inputrec->ePull != epullNO)
-      finish_pull(fplog,inputrec->pull);
+    snew(mc->xsave,mc->state->natoms);
+    snew(mc->vsave,mc->state->natoms);
+    start_t = do_hybrid(fplog,cr,nfile,fnm,
+			bVerbose,bCompact,
+			mc->vsite,constr,
+			nstepout,mc->inputrec,mc->mtop,
+			mc->fcd,mc->state,mc->f,mc->buf,
+			mc->mdatoms,mc->nrnb,mc->wcycle,ed,mc->fr,
+			repl_ex_nst,repl_ex_seed,
+			cpt_period,max_hours,
+			Flags,
+			&nsteps_done,&mc->mdebin,mc->xsave,mc->vsave);
+    clear_constr(constr);
+    if (mc->inputrec->ePull != epullNO)
+      finish_pull(fplog,mc->inputrec->pull);
   } else {
     /* do PME only */
-    gmx_pmeonly(*pmedata,cr,nrnb,wcycle,ewaldcoeff,FALSE);
+    gmx_pmeonly(*mc->pmedata,cr,mc->nrnb,mc->wcycle,mc->ewaldcoeff,FALSE);
+  }
+  
+//return values
+  mc->nsteps_done = nsteps_done;
+  return start_t;
+}
+
+void mdrunner_finalize(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+	               unsigned long Flags,
+		       time_t start_t,mdrunner_comm *mc)
+{
+  double nodetime=0,realtime;
+  /* Some timing stats */  
+  if (MASTER(cr)) {
+    realtime=difftime(time(NULL),start_t);
+    if ((nodetime=node_time()) == 0)
+      nodetime=realtime;
+  }
+  else 
+    realtime=0;
+
+  wallcycle_stop(mc->wcycle,ewcRUN);
+    
+  /* Finish up, write some stuff
+   * if rerunMD, don't write last frame again 
+   */
+  finish_run(fplog,cr,ftp2fn(efSTO,nfile,fnm),
+	     mc->inputrec,mc->nrnb,mc->wcycle,nodetime,realtime,mc->nsteps_done,
+	     EI_DYNAMICS(mc->inputrec->eI) && !MULTISIM(cr));
+  
+  /* Does what it says */  
+  print_date_and_time(fplog,cr->nodeid,"Finished mdrun");
+
+  /* Close logfile already here if we were appending to it */
+  if (MASTER(cr) && (Flags & MD_APPENDFILES))
+  {
+    gmx_log_close(fplog);
+  }
+}
+
+void mdrunner(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+	      bool bVerbose,bool bCompact,
+	      ivec ddxyz,int dd_node_order,real rdd,real rconstr,
+	      char *dddlb_opt,real dlb_scale,
+	      char *ddcsx,char *ddcsy,char *ddcsz,
+	      int nstepout,gmx_edsam_t ed,int repl_ex_nst,int repl_ex_seed,
+	      real pforce,real cpt_period,real max_hours,
+	      unsigned long Flags)
+{
+  double     nodetime=0,realtime;
+  t_inputrec *inputrec;
+  t_state    *state=NULL;
+  matrix     box;
+  rvec       *buf=NULL,*f=NULL;
+  real       tmpr1,tmpr2;
+  t_nrnb     *nrnb;
+  gmx_mtop_t *mtop=NULL;
+  t_mdatoms  *mdatoms=NULL;
+  t_forcerec *fr=NULL;
+  t_fcdata   *fcd=NULL;
+  real       ewaldcoeff=0;
+  gmx_pme_t  *pmedata=NULL;
+  time_t     start_t=0;
+  gmx_vsite_t *vsite=NULL;
+  gmx_constr_t constr;
+  int        i,m,nChargePerturbed=-1,status,nalloc;
+  char       *gro;
+  gmx_wallcycle_t wcycle;
+  bool       bReadRNG,bReadEkin;
+  int        list;
+  int        nsteps_done;
+	
+  snew(inputrec,1);
+  snew(mtop,1);
+  	
+  if (bVerbose && SIMMASTER(cr)) 
+    fprintf(stderr,"Getting Loaded...\n");
+  
+  if (Flags & MD_APPENDFILES) 
+  {
+	  fplog = NULL;
+  }
+	
+  if (PAR(cr)) {
+    /* The master thread on the master node reads from disk, 
+     * then distributes everything to the other processors.
+     */
+	
+    list = (SIMMASTER(cr) && !(Flags & MD_APPENDFILES)) ?  (LIST_SCALARS | LIST_INPUTREC) : 0;
+		  
+    snew(state,1);
+    init_parallel(fplog,ftp2fn(efTPX,nfile,fnm),cr,
+		  inputrec,mtop,state,list);
+	  
+  } else {
+    /* Read a file for a single processor */
+    snew(state,1);
+    init_single(fplog,inputrec,ftp2fn(efTPX,nfile,fnm),mtop,state);
+  }
+  if (!EEL_PME(inputrec->coulombtype) || (Flags & MD_PARTDEC)) {
+    cr->npmenodes = 0;
+  }
+  
+  /* NMR restraints must be initialized before load_checkpoint,
+   * since with time averaging the history is added to t_state.
+   * For proper consistency check we therefore need to extend
+   * t_state here.
+   * So the PME-only nodes (if present) will also initialize
+   * the distance restraints.
+   */
+  snew(fcd,1);
+
+  /* This needs to be called before read_checkpoint to extend the state */
+  init_disres(fplog,mtop,inputrec,cr,Flags & MD_PARTDEC,fcd,state);
+					  
+  if (gmx_mtop_ftype_count(mtop,F_ORIRES) > 0) {
+    if (PAR(cr) && !(Flags & MD_PARTDEC)) {
+      gmx_fatal(FARGS,"Orientation restraints do not work (yet) with domain decomposition, use particle decomposition (mdrun option -pd)");
+    }
+    /* Orientation restraints */
+    if (MASTER(cr)) {
+      init_orires(fplog,mtop,state->x,inputrec,cr->ms,&(fcd->orires),state);
+    }
+  }
+  
+  if (DEFORM(*inputrec)) {
+    /* Store the deform reference box before reading the checkpoint */
+    if (SIMMASTER(cr)) {
+      copy_mat(state->box,box);
+    }
+    if (PAR(cr)) {
+      gmx_bcast(sizeof(box),box,cr);
+    }
+    set_deform_reference_box(inputrec->init_step,box);
+  }
+
+  if (opt2bSet("-cpi",nfile,fnm)) 
+  {
+      /* Check if checkpoint file exists before doing continuation.
+       * This way we can use identical input options for the first and subsequent runs...
+       */
+      if( fexist(opt2fn("-cpi",nfile,fnm)) )
+      {
+	  load_checkpoint(opt2fn("-cpi",nfile,fnm),fplog,
+			  cr,Flags & MD_PARTDEC,ddxyz,
+			  inputrec,state,&bReadRNG,&bReadEkin,
+			  (Flags & MD_APPENDFILES));
+	  
+	  if (bReadRNG)
+	  {
+	      Flags |= MD_READ_RNG;
+	  }
+	  if (bReadEkin)
+	  {
+	      Flags |= MD_READ_EKIN;
+	  }
+      }
+  }
+  
+  if (MASTER(cr) && (Flags & MD_APPENDFILES))
+  {
+      fplog = gmx_log_open(ftp2fn(efLOG,nfile,fnm),cr, !(Flags & MD_SEPPOT) ,Flags);
+  }
+  
+  if (SIMMASTER(cr)) 
+  {
+      copy_mat(state->box,box);
+  }
+	
+  if (PAR(cr)) 
+  {
+      gmx_bcast(sizeof(box),box,cr);
+  }
+	
+  if (bVerbose && SIMMASTER(cr))
+    fprintf(stderr,"Loaded with Money\n\n");
+
+  if (PAR(cr) && !((Flags & MD_PARTDEC) || EI_TPI(inputrec->eI))) {
+    cr->dd = init_domain_decomposition(fplog,cr,Flags,ddxyz,rdd,rconstr,
+				       dddlb_opt,dlb_scale,
+				       ddcsx,ddcsy,ddcsz,
+				       mtop,inputrec,
+				       box,state->x);
+    
+    make_dd_communicators(fplog,cr,dd_node_order);
+
+    /* Set overallocation to avoid frequent reallocation of arrays */
+    set_over_alloc_dd(TRUE);
+  } else {
+    cr->duty = (DUTY_PP | DUTY_PME);
+
+    if (inputrec->ePBC == epbcSCREW)
+      gmx_fatal(FARGS,"pbc=%s is only implemented with domain decomposition",
+		epbc_names[inputrec->ePBC]);
+  }
+
+  if (PAR(cr)) {
+    /* After possible communicator splitting in make_dd_communicators.
+     * we can set up the intra/inter node communication.
+     */
+    gmx_setup_nodecomm(fplog,cr);
+  }
+	
+  wcycle = wallcycle_init(fplog,cr);
+
+  snew(nrnb,1);
+  if (cr->duty & DUTY_PP) {
+    /* For domain decomposition we allocate dynamically
+     * in dd_partition_system.
+     */
+    if (DOMAINDECOMP(cr)) {
+      bcast_state_setup(cr,state);
+    } else {
+      if (PAR(cr)) {
+	if (!MASTER(cr)) {
+	  snew(state,1);
+	}
+	bcast_state(cr,state,TRUE);
+      }
+
+      snew(buf,mtop->natoms);
+      snew(f,mtop->natoms);
+    }
+    
+    /* Dihedral Restraints */
+    if (gmx_mtop_ftype_count(mtop,F_DIHRES) > 0) {
+      init_dihres(fplog,mtop,inputrec,fcd);
+    }
+    
+    /* Initiate forcerecord */
+    fr = mk_forcerec();
+    init_forcerec(fplog,fr,fcd,inputrec,mtop,cr,box,FALSE,
+		  opt2fn("-table",nfile,fnm),opt2fn("-tablep",nfile,fnm),
+		  opt2fn("-tableb",nfile,fnm),FALSE,pforce);
+    fr->bSepDVDL = ((Flags & MD_SEPPOT) == MD_SEPPOT);
+    
+    /* Initialize QM-MM */
+    if(fr->bQMMM)
+      init_QMMMrec(cr,box,mtop,inputrec,fr);
+    
+    /* Initialize the mdatoms structure.
+     * mdatoms is not filled with atom data,
+     * as this can not be done now with domain decomposition.
+     */
+    mdatoms = init_mdatoms(fplog,mtop,inputrec->efep!=efepNO);
+    
+    /* Initialize the virtual site communication */
+    vsite = init_vsite(mtop,cr);
+
+    calc_shifts(box,fr->shift_vec);
+
+    /* With periodic molecules the charge groups should be whole at start up
+     * and the virtual sites should not be far from their proper positions.
+     */
+    if (!inputrec->bContinuation && MASTER(cr) &&
+	!(inputrec->ePBC != epbcNONE && inputrec->bPeriodicMols)) {
+      /* Make molecules whole at start of run */
+      if (fr->ePBC != epbcNONE)  {
+	do_pbc_first_mtop(fplog,inputrec->ePBC,box,mtop,state->x);
+      }
+      if (vsite) {
+	/* Correct initial vsite positions are required
+	 * for the initial distribution in the domain decomposition
+	 * and for the initial shell prediction.
+	 */
+	construct_vsites_mtop(fplog,vsite,mtop,state->x);
+      }
+    }
+	  
+    /* Initiate PPPM if necessary */
+    if (fr->eeltype == eelPPPM) {
+      if (mdatoms->nChargePerturbed)
+	gmx_fatal(FARGS,"Free energy with %s is not implemented",
+		  eel_names[fr->eeltype]);
+      status = gmx_pppm_init(fplog,cr,FALSE,TRUE,box,
+			     getenv("GMXGHAT"),inputrec, (Flags & MD_REPRODUCIBLE));
+      if (status != 0)
+	gmx_fatal(FARGS,"Error %d initializing PPPM",status);
+    }
+
+    if (EEL_PME(fr->eeltype)) {
+      ewaldcoeff = fr->ewaldcoeff;
+      pmedata = &fr->pmedata;
+    } else {
+      pmedata = NULL;
+    }
+  } else {
+    /* This is a PME only node */
+    
+    /* We don't need the state */
+    done_state(state);
+
+    ewaldcoeff = calc_ewaldcoeff(inputrec->rcoulomb, inputrec->ewald_rtol);
+    snew(pmedata,1);
+  }
+
+  /* Initiate PME if necessary,
+   * either on all nodes or on dedicated PME nodes only. */
+  if (EEL_PME(inputrec->coulombtype)) {
+    if (mdatoms) {
+      nChargePerturbed = mdatoms->nChargePerturbed;
+    }
+    if (cr->npmenodes > 0) {
+      /* The PME only nodes need to know nChargePerturbed */
+      gmx_bcast_sim(sizeof(nChargePerturbed),&nChargePerturbed,cr);
+    }
+    if (cr->duty & DUTY_PME) {
+      status = gmx_pme_init(pmedata,cr,inputrec,
+			    mtop ? mtop->natoms : 0,nChargePerturbed,
+			    (Flags & MD_REPRODUCIBLE));
+      if (status != 0)
+	gmx_fatal(FARGS,"Error %d initializing PME",status);
+    }
+  }
+  
+  if (integrator[inputrec->eI].func == do_md) {
+    /* Turn on signal handling on all nodes */
+    /*
+     * (A user signal from the PME nodes (if any)
+     * is communicated to the PP nodes.
+     */
+    if (getenv("GMX_NO_TERM") == NULL) {
+      if (debug)
+	fprintf(debug,"Installing signal handler for SIGTERM\n");
+      signal(SIGTERM,signal_handler);
+    }
+    if (getenv("GMX_NO_USR1") == NULL) {
+      if (debug)
+	fprintf(debug,"Installing signal handler for SIGUSR1\n");
+      signal(SIGUSR1,signal_handler);
+    }
+  }
+
+  if (cr->duty & DUTY_PP) {
+    if (inputrec->ePull != epullNO) {
+      /* Initialize pull code */
+      init_pull(fplog,inputrec,nfile,fnm,mtop,cr,
+		EI_DYNAMICS(inputrec->eI) && MASTER(cr),Flags);
+    }
+
+    constr = init_constraints(fplog,mtop,inputrec,ed,state,cr);
+
+    if (DOMAINDECOMP(cr)) {
+      dd_init_bondeds(fplog,cr->dd,mtop,vsite,constr,inputrec,
+		      Flags & MD_DDBONDCHECK,fr->cginfo_global);
+
+      set_dd_parameters(fplog,cr->dd,dlb_scale,inputrec,fr,box);
+     
+      setup_dd_grid(fplog,cr->dd);
+    }
+
+    /* Now do whatever the user wants us to do (how flexible...) */
+    start_t = integrator[inputrec->eI].func(fplog,cr,nfile,fnm,
+					    bVerbose,bCompact,
+					    vsite,constr,
+					    nstepout,inputrec,mtop,
+					    fcd,state,f,buf,
+					    mdatoms,nrnb,wcycle,ed,fr,
+					    repl_ex_nst,repl_ex_seed,
+					    cpt_period,max_hours,
+					    Flags,
+					    &nsteps_done);
+
+    if (inputrec->ePull != epullNO)
+      finish_pull(fplog,inputrec->pull);
+  } else {
+    /* do PME only */
+    gmx_pmeonly(*pmedata,cr,nrnb,wcycle,ewaldcoeff,FALSE);
+  }
+ 
+  /* Some timing stats */  
+  if (MASTER(cr)) {
+    realtime=difftime(time(NULL),start_t);
+    if ((nodetime=node_time()) == 0)
+      nodetime=realtime;
+  }
+  else 
+    realtime=0;
+
+  wallcycle_stop(wcycle,ewcRUN);
+    
+  /* Finish up, write some stuff
+   * if rerunMD, don't write last frame again 
+   */
+  finish_run(fplog,cr,ftp2fn(efSTO,nfile,fnm),
+	     inputrec,nrnb,wcycle,nodetime,realtime,nsteps_done,
+	     EI_DYNAMICS(inputrec->eI) && !MULTISIM(cr));
+  
+  /* Does what it says */  
+  print_date_and_time(fplog,cr->nodeid,"Finished mdrun");
+
+	/* Close logfile already here if we were appending to it */
+	if (MASTER(cr) && (Flags & MD_APPENDFILES))
+	{
+		gmx_log_close(fplog);
+	}	
+	
+}
+
+time_t do_md(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+	     bool bVerbose,bool bCompact,
+	     gmx_vsite_t *vsite,gmx_constr_t constr,
+	     int stepout,t_inputrec *ir,
+	     gmx_mtop_t *top_global,
+	     t_fcdata *fcd,
+	     t_state *state_global,rvec f[],
+	     rvec buf[],t_mdatoms *mdatoms,
+	     t_nrnb *nrnb,gmx_wallcycle_t wcycle,
+	     gmx_edsam_t ed,t_forcerec *fr,
+	     int repl_ex_nst,int repl_ex_seed,
+	     real cpt_period,real max_hours,
+	     unsigned long Flags,
+	     int *nsteps_done)
+{
+  int        fp_ene=0,fp_trn=0,fp_xtc=0,step,step_rel,step_ene;
+  char       *fn_cpt;
+  FILE       *fp_dgdl=NULL,*fp_field=NULL;
+  time_t     start_t;
+  double     run_time;
+  real       t,t0,lam0;
+  bool       bGStatEveryStep,bGStat;
+  bool       bNS,bSimAnn,bStopCM,bRerunMD,bNotLastFrame=FALSE,
+             bFirstStep,bStateFromTPX,bLastStep;
+  bool       bNEMD,do_ene,do_log,do_verbose,bRerunWarnNoV=TRUE,
+	         bForceUpdate=FALSE,bX,bV,bF,bXTC,bCPT;
+  bool       bMasterState;
+  tensor     force_vir,shake_vir,total_vir,pres,ekin;
+  int        i,m,status;
+  rvec       mu_tot;
+  t_vcm      *vcm;
+  int        step_ns=0,step_nscheck=0,nns=0,nabnsb=0,ns_lt;
+  double     ns_s1=0,ns_s2=0,ns_ab=0,ns_lt_runav=0,ns_lt_runav2=0;
+  matrix     *scale_tot;
+  t_trxframe rerun_fr;
+  gmx_repl_ex_t repl_ex=NULL;
+  int        nchkpt=1;
+  /* Booleans (disguised as a reals) to checkpoint and terminate mdrun */  
+  real       chkpt=0,terminate=0,terminate_now=0;
+
+  gmx_localtop_t *top;	
+  t_mdebin *mdebin=NULL;
+  t_state    *state=NULL;
+  rvec       *f_global=NULL;
+  gmx_enerdata_t *enerd;
+  gmx_stochd_t sd=NULL;
+  t_graph    *graph=NULL;
+
+  bool        bFFscan;
+  gmx_groups_t *groups;
+  gmx_ekindata_t *ekind;
+  gmx_shellfc_t shellfc;
+  int         count,nconverged=0;
+  real        timestep=0;
+  double      tcount=0;
+  bool        bHaveConstr=FALSE,bIonize=FALSE,bGlas=FALSE;
+  bool        bTCR=FALSE,bConverged=TRUE,bOK,bSumEkinhOld,bExchanged;
+  bool        bAppend;
+  real        temp0,mu_aver=0,dvdl;
+  int         a0,a1,gnx=0,ii;
+  atom_id     *grpindex=NULL;
+  char        *grpname;
+  t_coupl_rec *tcr=NULL;
+  rvec        *xcopy=NULL,*vcopy=NULL;
+  matrix      boxcopy,lastbox;
+  double      cycles;
+
+  /* Check for special mdrun options */
+  bRerunMD = (Flags & MD_RERUN);
+  bIonize  = (Flags & MD_IONIZE);
+  bGlas    = (Flags & MD_GLAS);
+  bFFscan  = (Flags & MD_FFSCAN);
+  bGStatEveryStep = !(Flags & MD_NOGSTAT);
+  bAppend  = (Flags & MD_APPENDFILES);
+	
+  if (!bGStatEveryStep && !EI_DYNAMICS(ir->eI)) {
+    char *warn="\nWARNING:\nNo energy summing can only be used with dynamics, ignoring this option\n";
+    fprintf(stderr,"%s\n",warn);
+    if (fplog)
+      fprintf(fplog,"%s\n",warn);
+    bGStatEveryStep = TRUE;
+  }
+
+  if (!bGStatEveryStep) {
+    if (fplog) {
+      fprintf(fplog,"\nWill not sum the energies at every step,\n"
+	      "therefore the energy file does not contain exact averages and fluctuations.\n\n");
+      if (ir->etc != etcNO || ir->epc != epcNO) {
+	fprintf(fplog,"WARNING:\nThe temperature and/or pressure for scaling will only be updated every nstlist (%d) steps\n\n",ir->nstlist);
+      }
+      if (ir->nstlist == -1) {
+	fprintf(fplog,
+		"To reduce the energy communication with nstlist = -1\n"
+		"the neighbor list validity should not be checked at every step,\n"
+		"this means that exact integration is not guaranteed.\n"
+		"The neighbor list validity is checked after:\n"
+		"  <n.list life time> - 2*std.dev.(n.list life time)  steps.\n"
+		"In most cases this will result in exact integration.\n"
+		"This reduces the energy communication by a factor of 2 to 3.\n"
+		"If you want less energy communication, set nstlist > 3.\n\n");
+      }
+    }
+    if (ir->comm_mode != ecmNO && ir->nstcomm == 1) {
+      if (fplog) {
+	fprintf(fplog,"WARNING:\nWe should not remove the COM motion every step with option -nosum,\n");
+      }
+      if (ir->nstlist > 0) {
+	ir->nstcomm = ir->nstlist;
+	if (fplog) {
+	  fprintf(fplog,"setting nstcomm to nstlist (%d)\n\n",ir->nstcomm);
+	}
+      } else {
+	ir->nstcomm = 100;
+	if (fplog) {
+	  fprintf(fplog,"setting nstcomm to %d\n\n",ir->nstcomm);
+	}
+      }
+    }
+  }
+
+  if (bRerunMD || bFFscan)
+    ir->nstxtcout = 0;
+
+  groups = &top_global->groups;
+
+  /* Initial values */
+  init_md(fplog,cr,ir,&t,&t0,&state_global->lambda,&lam0,
+          nrnb,top_global,&sd,
+          nfile,fnm,&fp_trn,&fp_xtc,&fp_ene,&fn_cpt,
+          &fp_dgdl,&fp_field,&mdebin,
+          force_vir,shake_vir,mu_tot,&bNEMD,&bSimAnn,&vcm,Flags);
+
+  /* Energy terms and groups */
+  snew(enerd,1);
+  init_enerdata(fplog,top_global->groups.grps[egcENER].nr,enerd);
+  /* Kinetic energy data */
+  snew(ekind,1);
+  init_ekindata(fplog,top_global,&(ir->opts),ekind);
+  /* Copy the cos acceleration to the groups struct */
+  ekind->cosacc.cos_accel = ir->cos_accel;
+
+  debug_gmx();
+
+  /* Check for polarizable models and flexible constraints */
+  shellfc = init_shell_flexcon(fplog,
+			       top_global,n_flexible_constraints(constr),
+			       (ir->bContinuation || 
+				(DOMAINDECOMP(cr) && !MASTER(cr))) ?
+			       NULL : state_global->x);
+
+  {
+    double io = compute_io(ir,top_global->natoms,groups,mdebin->ebin->nener,1);
+    if ((io > 2000) && MASTER(cr))
+      fprintf(stderr,
+	      "\nWARNING: This run will generate roughly %.0f Mb of data\n\n",
+	      io);
+  }
+ 
+  if (DOMAINDECOMP(cr)) {
+    top = dd_init_local_top(top_global);
+
+    snew(state,1);
+    dd_init_local_state(cr->dd,state_global,state);
+
+    if (DDMASTER(cr->dd) && ir->nstfout) {
+      snew(f_global,state_global->natoms);
+    }
+  } else {
+    if (PAR(cr)) {
+      /* Initialize the particle decomposition and split the topology */
+      top = split_system(fplog,top_global,ir,cr);
+
+      pd_cg_range(cr,&fr->cg0,&fr->hcg);
+      pd_at_range(cr,&a0,&a1);
+    } else {
+      top = gmx_mtop_generate_local_top(top_global,ir);
+
+      a0 = 0;
+      a1 = top_global->natoms;
+    }
+
+    state = partdec_init_local_state(cr,state_global);
+    f_global = f;
+
+    atoms2md(top_global,ir,0,NULL,a0,a1-a0,mdatoms);
+
+    if (vsite) {
+      set_vsite_top(vsite,top,mdatoms,cr);
+    }
+
+    if (ir->ePBC != epbcNONE && !ir->bPeriodicMols) {
+      graph = mk_graph(fplog,&(top->idef),0,top_global->natoms,FALSE,FALSE);
+    }
+
+    if (shellfc) {
+      make_local_shells(cr,mdatoms,shellfc);
+    }
+
+    if (ir->pull && PAR(cr)) {
+      dd_make_local_pull_groups(NULL,ir->pull,mdatoms);
+    }
+  }
+
+  if (DOMAINDECOMP(cr)) {
+    /* Distribute the charge groups over the nodes from the master node */
+    dd_partition_system(fplog,ir->init_step,cr,TRUE,
+			state_global,top_global,ir,
+			state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
+			nrnb,wcycle,FALSE);
+  }
+
+  update_mdatoms(mdatoms,state->lambda);
+
+  if (MASTER(cr))
+  {
+    /* Update mdebin with energy history if appending to output files */
+    if ( Flags & MD_APPENDFILES )
+    {
+      restore_energyhistory_from_state(mdebin,&state_global->enerhist);
+    }
+    /* Set the initial energy history in state to zero by updating once */
+    update_energyhistory(&state_global->enerhist,mdebin);
+  }	
+	
+	
+  if (sd && (Flags & MD_READ_RNG)) {
+    /* Set the random state if we read a checkpoint file */
+    set_stochd_state(sd,state);
+  }
+
+  /* Initialize constraints */
+  if (constr) {
+    if (!DOMAINDECOMP(cr))
+      set_constraints(constr,top,ir,mdatoms,NULL);
+    bHaveConstr = TRUE;
+  }
+
+  /* Check whether we have to GCT stuff */
+  bTCR = ftp2bSet(efGCT,nfile,fnm);
+  if (bTCR) {
+    if (MASTER(cr)) {
+      fprintf(stderr,"Will do General Coupling Theory!\n");
+    }
+    gnx = top_global->mols.nr;
+    snew(grpindex,gnx);
+    for(i=0; (i<gnx); i++) {
+      grpindex[i] = i;
+    }
+  }
+  
+
+  if (repl_ex_nst > 0 && MASTER(cr)) {
+    repl_ex = init_replica_exchange(fplog,cr->ms,state_global,ir,
+				    repl_ex_nst,repl_ex_seed);
+
+    if (max_hours > 0 && MASTERSIM(cr->ms)) {
+      fprintf(stderr,"\nWARNING: Using -maxh with REMD can cause the simulation to hang after maxh hours\n\n");
+    }
+  }
+
+  if (!ir->bContinuation && !bRerunMD) {
+    if (mdatoms->cFREEZE && (state->flags & (1<<estV))) {
+      /* Set the velocities of frozen particles to zero */
+      for(i=mdatoms->start; i<mdatoms->homenr; i++) {
+	for(m=0; m<DIM; m++) {
+	  if (ir->opts.nFreeze[mdatoms->cFREEZE[i]][m]) {
+	    state->v[i][m] = 0;
+	  }
+	}
+      }
+    }
+    if (bHaveConstr) {
+      /* Constrain the initial coordinates and velocities */
+      do_shakefirst(fplog,constr,ir,mdatoms,state,buf,f,
+		    graph,cr,nrnb,fr,&top->idef);
+    }
+    if (vsite) {
+      /* Construct the virtual sites for the initial configuration */
+      construct_vsites(fplog,vsite,state->x,nrnb,ir->delta_t,NULL,
+		       top->idef.iparams,top->idef.il,
+		       fr->ePBC,fr->bMolPBC,graph,cr,state->box);
+    }
+  }
+
+  debug_gmx();
+
+  if (Flags & MD_READ_EKIN)
+  {
+      restore_ekinstate_from_state(cr,ekind,&state_global->ekinstate);
+  }
+  else
+  {
+      /* Compute initial EKin for all.. */
+      if (ekind->cosacc.cos_accel == 0) {
+          calc_ke_part(state->v,&(ir->opts),mdatoms,ekind,nrnb,state->lambda);
+      } else {
+	  calc_ke_part_visc(state->box,state->x,state->v,&(ir->opts),
+			    mdatoms,ekind,nrnb,state->lambda);
+      }
+      debug_gmx();
+
+      if (PAR(cr))
+      {
+	  GMX_MPE_LOG(ev_global_stat_start);
+	  
+	  global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
+		      ir,ekind,FALSE,constr,vcm,NULL,NULL,&terminate);
+	  
+	  GMX_MPE_LOG(ev_global_stat_finish);
+      }
+       debug_gmx();
+  }
+  
+  /* Calculate the initial half step temperature */
+  temp0 = sum_ekin(TRUE,&(ir->opts),ekind,ekin,NULL);
+
+  debug_gmx();
+   
+  /* Initiate data for the special cases */
+  if (bFFscan) {
+    snew(xcopy,state->natoms);
+    snew(vcopy,state->natoms);
+    for(ii=0; (ii<state->natoms); ii++) {
+      copy_rvec(state->x[ii],xcopy[ii]);
+      copy_rvec(state->v[ii],vcopy[ii]);
+    }
+    copy_mat(state->box,boxcopy);
+  } 
+
+  if (MASTER(cr)) {
+    if (constr && !ir->bContinuation && ir->eConstrAlg == econtLINCS)
+      fprintf(fplog,
+	      "RMS relative constraint deviation after constraining: %.2e\n",
+	      constr_rmsd(constr,FALSE));
+    fprintf(fplog,"Initial temperature: %g K\n",temp0);
+    if (bRerunMD) {
+      fprintf(stderr,"starting md rerun '%s', reading coordinates from"
+	      " input trajectory '%s'\n\n",
+	      *(top_global->name),opt2fn("-rerun",nfile,fnm));
+      if (bVerbose)
+	fprintf(stderr,"Calculated time to finish depends on nsteps from "
+		"run input file,\nwhich may not correspond to the time "
+		"needed to process input trajectory.\n\n");
+    } else {
+		if(ir->init_step>0)
+		{
+			fprintf(stderr,"starting mdrun '%s'\n%d steps, %8.1f ps (continuing from step %d, %8.1f ps).\n",
+					*(top_global->name),ir->nsteps+ir->init_step,(ir->nsteps+ir->init_step)*ir->delta_t,
+					ir->init_step,ir->init_step*ir->delta_t);
+		}
+		else
+		{
+			fprintf(stderr,"starting mdrun '%s'\n%d steps, %8.1f ps.\n",
+					*(top_global->name),ir->nsteps,ir->nsteps*ir->delta_t);
+		}
+    }
+    fprintf(fplog,"\n");
+  }
+
+  if (ir->nstlist == -1) {
+    snew(scale_tot,1);
+  } else {
+    scale_tot = NULL;
+  }
+
+  /* Write start time */
+  start_t=print_date_and_time(fplog,cr->nodeid,"Started mdrun");
+  wallcycle_start(wcycle,ewcRUN);
+  if (fplog)
+    fprintf(fplog,"\n");
+
+  /* Set the node time counter to 0 after initialisation */
+  start_time();
+  debug_gmx();
+  /***********************************************************
+   *
+   *             Loop over MD steps 
+   *
+   ************************************************************/
+  
+  /* if rerunMD then read coordinates and velocities from input trajectory */
+  if (bRerunMD) {
+    if (getenv("GMX_FORCE_UPDATE"))
+      bForceUpdate = TRUE;
+
+    bNotLastFrame = read_first_frame(&status,opt2fn("-rerun",nfile,fnm),
+				     &rerun_fr,TRX_NEED_X | TRX_READ_V);
+    if (rerun_fr.natoms != top_global->natoms)
+      gmx_fatal(FARGS,"Number of atoms in trajectory (%d) does not match the "
+		"run input file (%d)\n",rerun_fr.natoms,top_global->natoms);
+    if (ir->ePBC != epbcNONE) {
+      if (!rerun_fr.bBox)
+	gmx_fatal(FARGS,"Rerun trajectory frame step %d time %f does not contain a box, while pbc is used",rerun_fr.step,rerun_fr.time);
+      if (max_cutoff2(ir->ePBC,rerun_fr.box) < sqr(fr->rlistlong))
+	gmx_fatal(FARGS,"Rerun trajectory frame step %d time %f has too small box dimensions",rerun_fr.step,rerun_fr.time);
+
+      /* Set the shift vectors.
+       * Necessary here when have a static box different from the tpr box.
+       */
+      calc_shifts(rerun_fr.box,fr->shift_vec);
+    }
+  }
+
+  /* loop over MD steps or if rerunMD to end of input trajectory */
+  bFirstStep = TRUE;
+  /* Skip the first Nose-Hoover integration when we get the state from tpx */
+  bStateFromTPX = !opt2bSet("-cpi",nfile,fnm);
+  bLastStep = FALSE;
+  bSumEkinhOld = FALSE,
+  bExchanged = FALSE;
+
+  step = ir->init_step;
+  step_rel = 0;
+  step_ene = 0;
+
+  bLastStep = (bRerunMD || step_rel > ir->nsteps);
+  while (!bLastStep || (bRerunMD && bNotLastFrame)) {
+
+    wallcycle_start(wcycle,ewcSTEP);
+
+    GMX_MPE_LOG(ev_timestep1);
+
+    if (bRerunMD) {
+      if (rerun_fr.bStep) {
+	step = rerun_fr.step;
+	step_rel = step - ir->init_step;
+      }
+      if (rerun_fr.bTime)
+	t = rerun_fr.time;
+      else
+	t = step;
+    } else {
+      bLastStep = (step_rel == ir->nsteps);
+
+      t = t0 + step*ir->delta_t;
+    }
+    if (Flags & MD_APPENDFILES) {
+      step_ene = step;
+    } else {
+      step_ene = step_rel;
+    }
+
+    if (ir->efep != efepNO) {
+      if (bRerunMD && rerun_fr.bLambda && (ir->delta_lambda!=0))
+	state_global->lambda = rerun_fr.lambda;
+      else
+	state_global->lambda = lam0 + step*ir->delta_lambda;
+      state->lambda = state_global->lambda;
+    }
+    
+    if (bSimAnn) 
+      update_annealing_target_temp(&(ir->opts),t);
+    
+    if (bRerunMD) {
+      if (!(DOMAINDECOMP(cr) && !MASTER(cr))) {
+	for(i=0; i<state_global->natoms; i++) {
+	  copy_rvec(rerun_fr.x[i],state_global->x[i]);
+	}
+	if (rerun_fr.bV) {
+	  for(i=0; i<state_global->natoms; i++) {
+	    copy_rvec(rerun_fr.v[i],state_global->v[i]);
+	  }
+	} else {
+	  for(i=0; i<state_global->natoms; i++) {
+	    clear_rvec(state_global->v[i]);
+	  }
+	  if (bRerunWarnNoV) {
+	    fprintf(stderr,"\nWARNING: Some frames do not contain velocities.\n"
+		    "         Ekin, temperature and pressure are incorrect,\n"
+		    "         the virial will be incorrect when constraints are present.\n"
+		    "\n");
+	    bRerunWarnNoV = FALSE;
+	  }
+	}
+      }
+      copy_mat(rerun_fr.box,state_global->box);
+      copy_mat(state_global->box,state->box);
+
+      if (vsite && (Flags & MD_RERUN_VSITE)) {
+	if (DOMAINDECOMP(cr)) {
+	  gmx_fatal(FARGS,"Vsite recalculation with -rerun is not implemented for domain decomposition, use particle decomposition");
+	}
+	if (graph) {
+	  /* Following is necessary because the graph may get out of sync
+	   * with the coordinates if we only have every N'th coordinate set
+	   */
+	  mk_mshift(fplog,graph,fr->ePBC,state->box,state->x);
+	  shift_self(graph,state->box,state->x);
+	}
+	construct_vsites(fplog,vsite,state->x,nrnb,ir->delta_t,state->v,
+			 top->idef.iparams,top->idef.il,
+			 fr->ePBC,fr->bMolPBC,graph,cr,state->box);
+	if (graph)
+	  unshift_self(graph,state->box,state->x);
+      }
+    }
+
+    /* Stop Center of Mass motion */
+    bStopCM = (ir->comm_mode != ecmNO && do_per_step(step,ir->nstcomm));
+
+    /* Copy back starting coordinates in case we're doing a forcefield scan */
+    if (bFFscan) {
+      for(ii=0; (ii<state->natoms); ii++) {
+	copy_rvec(xcopy[ii],state->x[ii]);
+	copy_rvec(vcopy[ii],state->v[ii]);
+      }
+      copy_mat(boxcopy,state->box);
+    }
+    
+    bNS = bFirstStep;
+    if (bRerunMD) {
+      /* for rerun MD always do Neighbour Searching */
+      if (ir->nstlist != 0) {
+	bNS = TRUE;
+      }
+    } else {
+      /* Determine whether or not to do Neighbour Searching */
+      if (bExchanged || (ir->nstlist > 0 && (step % ir->nstlist == 0))) {
+	bNS = TRUE;
+      } else if (ir->nstlist == -1) {
+	bNS = (bFirstStep || nabnsb > 0);
+	if (bNS) {
+	  if (bFirstStep) {
+	    ns_lt_runav = 0;
+	    step_nscheck = step;
+	  } else {
+	    /* Determine the neighbor list life time */
+	    ns_lt = step - step_ns;
+	    if (debug) {
+	      fprintf(debug,"%d atoms beyond ns buffer, updating neighbor list after %d steps\n",nabnsb,ns_lt);
+	    }
+	    nns++;
+	    ns_s1 += ns_lt;
+	    ns_s2 += ns_lt*ns_lt;
+	    ns_ab += nabnsb;
+	    if (ns_lt_runav == 0) {
+	      ns_lt_runav  = ns_lt;
+	      /* Initialize the fluctuation average such that at startup
+	       * we check after 0 steps.
+	       */
+	      ns_lt_runav2 = sqr(ns_lt/2.0);
+	    }
+	    /* Running average with 0.9 gives an exp. history of 9.5 */
+	    ns_lt_runav2 = 0.9*ns_lt_runav2 + 0.1*sqr(ns_lt_runav - ns_lt);
+	    ns_lt_runav  = 0.9*ns_lt_runav  + 0.1*ns_lt;
+	    if (bGStatEveryStep) {
+	      /* Always check the nlist validity */
+	      step_nscheck = step;
+	    } else {
+	      /* We check after:  <life time> - 2*sigma
+	       * The factor 2 is quite conservative,
+	       * but we assume that with nstlist=-1 the user prefers
+	       * exact integration over performance.
+	       */
+	      step_nscheck = step
+		+ (int)(ns_lt_runav - 2.0*sqrt(ns_lt_runav2)) - 1;
+	    }
+	    if (debug) {
+	      fprintf(debug,"nlist life time %d run av. %4.1f sig %3.1f check %d check with -nosum %d\n",
+		      ns_lt,ns_lt_runav,sqrt(ns_lt_runav2),
+		      step_nscheck-step+1,
+		      (int)(ns_lt_runav - 2.0*sqrt(ns_lt_runav2)));
+	    }
+	  }
+	  step_ns = step;
+	  /* Initialize the cumulative coordinate scaling matrix */
+	  clear_mat(*scale_tot);
+	  for(ii=0; ii<DIM; ii++)
+	    (*scale_tot)[ii][ii] = 1.0;
+	}
+      }
+    } 
+
+    if (terminate_now > 0 || (terminate_now < 0 && bNS)) {
+      bLastStep = TRUE;
+    }
+
+    do_log = do_per_step(step,ir->nstlog) || bFirstStep || bLastStep;
+    do_verbose = bVerbose && (step % stepout == 0 || bFirstStep || bLastStep);
+
+    if (bNS && !(bFirstStep && ir->bContinuation && !bRerunMD)) {
+      if (bRerunMD) {
+	bMasterState = TRUE;
+      } else {
+	bMasterState = FALSE;
+	/* Correct the new box if it is too skewed */
+	if (DYNAMIC_BOX(*ir)) {
+	  if (correct_box(fplog,step,state->box,graph))
+	    bMasterState = TRUE;
+	}
+	if (DOMAINDECOMP(cr) && bMasterState)
+	  dd_collect_state(cr->dd,state,state_global);
+      }
+      
+      if (DOMAINDECOMP(cr)) {
+	/* Repartition the domain decomposition */
+	wallcycle_start(wcycle,ewcDOMDEC);
+	dd_partition_system(fplog,step,cr,bMasterState,
+			    state_global,top_global,ir,
+			    state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
+			    nrnb,wcycle,do_verbose);
+	wallcycle_stop(wcycle,ewcDOMDEC);
+      }
+    }
+
+    if (MASTER(cr) && do_log && !bFFscan)
+      print_ebin_header(fplog,step,t,state->lambda);
+
+    if (ir->efep != efepNO)
+      update_mdatoms(mdatoms,state->lambda); 
+
+    if (bRerunMD && rerun_fr.bV) {
+      /* We need the kinetic energy at minus the half step for determining
+       * the full step kinetic energy and possibly for T-coupling.
+       */
+      calc_ke_part(state->v,&(ir->opts),mdatoms,ekind,nrnb,state->lambda);
+      if (PAR(cr)) {
+	global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
+		    ir,ekind,FALSE,constr,vcm,NULL,NULL,&terminate);
+      }
+      sum_ekin(FALSE,&(ir->opts),ekind,ekin,NULL);
+    }
+    
+    clear_mat(force_vir);
+    
+    /* Ionize the atoms if necessary */
+    if (bIonize) {
+      ionize(fplog,mdatoms,top_global,t,ir,state->x,state->v,
+	     mdatoms->start,mdatoms->start+mdatoms->homenr,state->box,cr);
+    }
+      
+    /* Update force field in ffscan program */
+    if (bFFscan) {
+      if (update_forcefield(fplog,
+			    nfile,fnm,fr,mdatoms->nr,state->x,state->box)) {
+	if (gmx_parallel_env)
+	  gmx_finalize(cr);
+	exit(0);
+      }
+    }
+
+    GMX_MPE_LOG(ev_timestep2);
+
+    if (shellfc) {
+      /* Now is the time to relax the shells */
+      count=relax_shell_flexcon(fplog,cr,bVerbose,bFFscan ? step+1 : step,
+				ir,bNS,bStopCM,top,constr,enerd,fcd,
+				state,f,buf,force_vir,mdatoms,
+				nrnb,wcycle,graph,groups,
+				shellfc,fr,t,mu_tot,
+				state->natoms,&bConverged,vsite,
+				fp_field);
+      tcount+=count;
+      
+      if (bConverged)
+	nconverged++;
+    }
+    else {
+      /* The coordinates (x) are shifted (to get whole molecules) in do_force
+       * This is parallellized as well, and does communication too. 
+       * Check comments in sim_util.c
+       */
+      do_force(fplog,cr,ir,step,nrnb,wcycle,top,groups,
+	       state->box,state->x,&state->hist,
+	       f,buf,force_vir,mdatoms,enerd,fcd,
+	       state->lambda,graph,
+	       fr,vsite,mu_tot,t,fp_field,ed,
+	       GMX_FORCE_STATECHANGED | (bNS ? GMX_FORCE_NS : 0) |
+	       GMX_FORCE_ALLFORCES);
+    }
+
+    GMX_BARRIER(cr->mpi_comm_mygroup);
+
+    if (bTCR)
+      mu_aver = calc_mu_aver(cr,state->x,mdatoms->chargeA,
+			     mu_tot,&top_global->mols,mdatoms,gnx,grpindex);
+    if (bGlas)
+      do_glas(fplog,mdatoms->start,mdatoms->homenr,state->x,f,
+	      fr,mdatoms,top->idef.atnr,ir,enerd->term);
+    
+    if (bTCR && bFirstStep) {
+      tcr=init_coupling(fplog,nfile,fnm,cr,fr,mdatoms,&(top->idef));
+      fprintf(fplog,"Done init_coupling\n"); 
+      fflush(fplog);
+    }
+
+    /* Now we have the energies and forces corresponding to the 
+     * coordinates at time t. We must output all of this before
+     * the update.
+     * for RerunMD t is read from input trajectory
+     */
+
+    GMX_MPE_LOG(ev_output_start);
+
+    bX   = do_per_step(step,ir->nstxout);
+    bV   = do_per_step(step,ir->nstvout);
+    bF   = do_per_step(step,ir->nstfout);
+    bXTC = do_per_step(step,ir->nstxtcout);
+    if ((bNS || bLastStep) && (step > ir->init_step) && !bRerunMD) {
+      bCPT = ((chkpt < 0 && do_per_step(step,ir->nstenergy)) || chkpt > 0 ||
+	       bLastStep);
+      if (bCPT) {
+	chkpt = 0;
+      }
+    } else {
+      bCPT = FALSE;
+    }
+
+    if (bX || bV || bF || bXTC || bCPT) {
+      wallcycle_start(wcycle,ewcTRAJ);
+      if (bCPT) {
+	if (sd) {
+	  get_stochd_state(sd,state);
+	}
+	if (MASTER(cr)) {
+	  if (bSumEkinhOld) {
+	    state_global->ekinstate.bUpToDate = FALSE;
+	  } else {
+	    update_ekinstate(&state_global->ekinstate,ekind);
+	    state_global->ekinstate.bUpToDate = TRUE;
+	  }
+	  update_energyhistory(&state_global->enerhist,mdebin);
+	}
+      }
+      write_traj(fplog,cr,fp_trn,bX,bV,bF,fp_xtc,bXTC,ir->xtcprec,fn_cpt,bCPT,
+				 top_global,ir->eI,ir->simulation_part,step,t,state,state_global,f,f_global);
+      debug_gmx();
+
+      if (bLastStep && step_rel == ir->nsteps &&
+	  (Flags & MD_CONFOUT) && MASTER(cr) &&
+	  !bRerunMD && !bFFscan) {
+	/* x and v have been collected in write_traj */
+	fprintf(stderr,"\nWriting final coordinates.\n");
+	if (ir->ePBC != epbcNONE && !ir->bPeriodicMols && DOMAINDECOMP(cr)) {
+	  /* Make molecules whole only for confout writing */
+	  do_pbc_mtop(fplog,ir->ePBC,state->box,top_global,state_global->x);
+	}
+	write_sto_conf_mtop(ftp2fn(efSTO,nfile,fnm),
+			    *top_global->name,top_global,
+			    state_global->x,state_global->v,
+			    ir->ePBC,state->box);
+	debug_gmx();
+      }
+      wallcycle_stop(wcycle,ewcTRAJ);
+    }
+    
+    GMX_MPE_LOG(ev_output_finish);
+
+    clear_mat(shake_vir);
+
+    if (bFFscan)
+      clear_rvecs(state->natoms,buf);
+
+    /* Box is changed in update() when we do pressure coupling,
+     * but we should still use the old box for energy corrections and when
+     * writing it to the energy file, so it matches the trajectory files for
+     * the same timestep above. Make a copy in a separate array.
+     */
+    copy_mat(state->box,lastbox);
+ 
+    
+    GMX_MPE_LOG(ev_update_start);
+    /* This is also parallellized, but check code in update.c */
+    /* bOK = update(nsb->natoms,START(nsb),HOMENR(nsb),step,state->lambda,&ener[F_DVDL], */
+    bOK = TRUE;
+    if (!bRerunMD || rerun_fr.bV || bForceUpdate) {
+      wallcycle_start(wcycle,ewcUPDATE);
+      dvdl = 0;
+      /* We can only do Berendsen coupling after we have summed the kinetic
+       * energy or virial. Since the happens in global_state after update,
+       * we should only do it at step % nstlist = 1 with bGStatEveryStep=FALSE.
+       */
+      update(fplog,step,&dvdl,ir,mdatoms,state,graph,f,buf,fcd,
+	     &top->idef,ekind,shake_vir,scale_tot,
+	     cr,nrnb,wcycle,sd,constr,bHaveConstr,
+	     bNEMD,bFirstStep && bStateFromTPX);
+      if (fr->bSepDVDL && fplog && do_log) {
+	fprintf(fplog,sepdvdlformat,"Constraint",0.0,dvdl);
+      }
+      enerd->term[F_DGDL_CON] += dvdl;
+      wallcycle_stop(wcycle,ewcUPDATE);
+    } else if (graph) {
+      /* Need to unshift here */
+      unshift_self(graph,state->box,state->x);
+    }
+
+    GMX_BARRIER(cr->mpi_comm_mygroup);
+    GMX_MPE_LOG(ev_update_finish);
+
+    if (!bOK && !bFFscan)
+      gmx_fatal(FARGS,"Constraint error: Shake, Lincs or Settle could not solve the constrains");
+
+    if (vsite) {
+      wallcycle_start(wcycle,ewcVSITECONSTR);
+      if (graph)
+	shift_self(graph,state->box,state->x);
+      
+      construct_vsites(fplog,vsite,state->x,nrnb,ir->delta_t,state->v,
+		       top->idef.iparams,top->idef.il,
+		       fr->ePBC,fr->bMolPBC,graph,cr,state->box);
+     
+      if (graph)
+	unshift_self(graph,state->box,state->x);
+      wallcycle_stop(wcycle,ewcVSITECONSTR);
+    }
+
+    /* Non-equilibrium MD: this is parallellized, but only does communication
+     * when there really is NEMD.
+     */
+    if (PAR(cr) && bNEMD) 
+      accumulate_u(cr,&(ir->opts),ekind);
+      
+    debug_gmx();
+    if (ekind->cosacc.cos_accel == 0) {
+      calc_ke_part(state->v,&(ir->opts),mdatoms,ekind,nrnb,state->lambda);
+    } else {
+      calc_ke_part_visc(state->box,state->x,state->v,&(ir->opts),
+			mdatoms,ekind,nrnb,state->lambda);
+    }
+
+    /* since we use the new coordinates in calc_ke_part_visc, we should use
+     * the new box too. Still, won't this be offset by one timestep in the
+     * energy file? / EL 20040121
+     */ 
+
+    debug_gmx();
+    /* Calculate center of mass velocity if necessary, also parallellized */
+    if (bStopCM && !bFFscan && !bRerunMD)
+      calc_vcm_grp(fplog,mdatoms->start,mdatoms->homenr,mdatoms,
+		   state->x,state->v,vcm);
+    
+    /* Determine the wallclock run time up till now */
+    run_time = (double)time(NULL) - (double)start_t;
+
+    /* Check whether everything is still allright */    
+    if (bGotTermSignal || bGotUsr1Signal) {
+      if (bGotTermSignal || ir->nstlist == 0)
+	terminate = 1;
+      else
+	terminate = -1;
+      if (!PAR(cr))
+	terminate_now = terminate;
+      if (fplog) {
+	fprintf(fplog,
+		"\n\nReceived the %s signal, stopping at the next %sstep\n\n",
+		bGotTermSignal ? "TERM" : "USR1",terminate==-1 ? "NS " : "");
+	fflush(fplog);
+      }
+      fprintf(stderr,
+	      "\n\nReceived the %s signal, stopping at the next %sstep\n\n",
+	      bGotTermSignal ? "TERM" : "USR1",terminate==-1 ? "NS " : "");
+      fflush(stderr);
+      bGotTermSignal = FALSE;
+      bGotUsr1Signal = FALSE;
+    } else if (MASTER(cr) && (bNS || ir->nstlist <= 0) &&
+	       (max_hours > 0 && run_time > max_hours*60.0*60.0*0.99) &&
+	       terminate == 0) {
+      /* Signal to terminate the run */
+      terminate = (ir->nstlist == 0 ? 1 : -1);
+      if (!PAR(cr))
+	terminate_now = terminate;
+     if (fplog)
+	fprintf(fplog,"\nStep %d: Run time exceeded %.3f hours, will terminate the run\n",step,max_hours*0.99);
+      fprintf(stderr, "\nStep %d: Run time exceeded %.3f hours, will terminate the run\n",step,max_hours*0.99);
+    }
+    
+    bGStat = (bGStatEveryStep || bStopCM);
+
+    if (ir->nstlist == -1 && !bRerunMD) {
+      /* When bGStatEveryStep=FALSE, global_stat is only called
+       * when we check the atom displacements, not at NS steps.
+       * This means that also the bonded interaction count check is not
+       * performed immediately after NS. Therefore a few MD steps could
+       * be performed with missing interactions. But wrong energies are never
+       * written to file, since energies are only written after global_stat
+       * has been called.
+       */
+      if (step >= step_nscheck) {
+	nabnsb = natoms_beyond_ns_buffer(ir,fr,&top->cgs,*scale_tot,state->x);
+	bGStat = TRUE;
+      } else {
+	/* This is not necessarily true,
+	 * but step_nscheck is determined quite conservatively.
+	 */
+	nabnsb = 0;
+      }
+    } else {
+      if (bNS) {
+	bGStat = TRUE;
+      }
+    }
+
+    /* In parallel we only have to check for checkpointing in steps
+     * where we do global communication, otherwise the other nodes don't know.
+     */
+    if (MASTER(cr) && ((bGStat || !PAR(cr)) &&
+		       cpt_period >= 0 &&
+		       (cpt_period == 0 || 
+			run_time >= nchkpt*cpt_period*60.0))) {
+      if (chkpt == 0) {
+	nchkpt++;
+      }
+      /* Write checkpoint at the next energy output step (if there is one),
+       * or after 0.2*cpt_period at any step.
+       */
+      if (!bGStatEveryStep || ir->nstenergy == 0 || cpt_period == 0 ||
+	  run_time >= (nchkpt + 0.2)*cpt_period*60.0) {
+	chkpt = 1;
+      } else {
+	chkpt = -1;
+      }
+    }
+
+    /* With exact energy averages (bGStatEveryStep=TRUE)
+     * we should also write energy at first, last and continuation steps
+     * such that we can get exact averages over a series of runs.
+     * We therefore try to checkpoint at energy output frames.
+     *
+     * This is not necessary when we use the append-file-feature, so we avoid
+     * the extra first frame in that case.
+     */
+    do_ene = (do_per_step(step,ir->nstenergy) ||
+	      (bGStatEveryStep && ((bFirstStep && !bAppend) ||
+				   bLastStep || bCPT)));
+
+    if (do_ene || do_log) {
+      bGStat = TRUE;
+    }
+
+    if (!bGStat) {
+      /* We will not sum ekinh_old, so signal that we still have to do it */
+      bSumEkinhOld = TRUE;
+    } else {
+      if (PAR(cr)) {
+	wallcycle_start(wcycle,ewcMoveE);
+	/* Globally (over all NODEs) sum energy, virial etc. 
+	 * This includes communication 
+	 */
+	global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
+		    ir,ekind,bSumEkinhOld,constr,vcm,
+		    ir->nstlist==-1 ? &nabnsb : NULL,&chkpt,&terminate);
+	if (terminate != 0) {
+	  terminate_now = terminate;
+	  terminate = 0;
+	}
+	
+	wallcycle_stop(wcycle,ewcMoveE);
+	bSumEkinhOld = FALSE;
+      }
+
+      /* This is just for testing. Nothing is actually done to Ekin
+       * since that would require extra communication.
+       */
+      if (!bNEMD && debug && (vcm->nr > 0)) {
+	correct_ekin(debug,mdatoms->start,mdatoms->start+mdatoms->homenr,
+		     state->v,vcm->group_p[0],
+		     mdatoms->massT,mdatoms->tmass,ekin);
+      }
+    
+      /* Do center of mass motion removal */
+      if (bStopCM && !bFFscan && !bRerunMD) {
+	check_cm_grp(fplog,vcm,1);
+	do_stopcm_grp(fplog,mdatoms->start,mdatoms->homenr,mdatoms->cVCM,
+		      state->x,state->v,vcm);
+	inc_nrnb(nrnb,eNR_STOPCM,mdatoms->homenr);
+	/*
+	  calc_vcm_grp(fplog,START(nsb),HOMENR(nsb),mdatoms->massT,x,v,vcm);
+	  check_cm_grp(fplog,vcm);
+	  do_stopcm_grp(fplog,START(nsb),HOMENR(nsb),x,v,vcm);
+	  check_cm_grp(fplog,vcm);
+	*/
+      }
+      
+      /* Add force and shake contribution to the virial */
+      m_add(force_vir,shake_vir,total_vir);
+      
+      /* Calculate the amplitude of the cosine velocity profile */
+      ekind->cosacc.vcos = ekind->cosacc.mvcos/mdatoms->tmass;
+      
+      /* Sum the kinetic energies of the groups & calc temp */
+      enerd->term[F_TEMP] = sum_ekin((bRerunMD && !rerun_fr.bV),
+				     &(ir->opts),ekind,ekin,
+				     &(enerd->term[F_DKDL]));
+      enerd->term[F_EKIN] = trace(ekin);
+      
+      /* Calculate pressure and apply LR correction if PPPM is used.
+       * Use the box from last timestep since we already called update().
+       */
+      enerd->term[F_PRES] =
+	calc_pres(fr->ePBC,ir->nwall,lastbox,ekin,total_vir,pres,
+		  (fr->eeltype==eelPPPM)?enerd->term[F_COUL_RECIP]:0.0);
+      
+      /* Calculate long range corrections to pressure and energy */
+      if (bTCR || bFFscan) {
+	set_avcsixtwelve(fplog,fr,top_global);
+      }
+      
+      /* Calculate long range corrections to pressure and energy */
+      calc_dispcorr(fplog,ir,fr,step,top_global->natoms,
+		    lastbox,state->lambda,
+		    pres,total_vir,enerd->term);
+      
+      enerd->term[F_ETOT] = enerd->term[F_EPOT] + enerd->term[F_EKIN];
+      
+      switch (ir->etc) {
+      case etcNO:
+      case etcBERENDSEN:
+	break;
+      case etcNOSEHOOVER:
+	enerd->term[F_ECONSERVED] =
+	  enerd->term[F_ETOT] + nosehoover_energy(&(ir->opts),ekind,
+						  state->nosehoover_xi,
+						  state->therm_integral);
+	break;
+      case etcVRESCALE:
+	enerd->term[F_ECONSERVED] =
+	  enerd->term[F_ETOT] + vrescale_energy(&(ir->opts),
+						state->therm_integral);
+	break;
+      }
+      
+      /* Complicated conditional when bGStatEveryStep=FALSE.
+       * We can not just use bGStat, since then the simulation results
+       * would depend on nstenergy and nstlog or step_nscheck.
+       */
+      if ((state->flags & (1<<estPRES_PREV)) &&
+	  (bGStatEveryStep ||
+	   (ir->nstlist > 0 && step % ir->nstlist == 0) ||
+	   (ir->nstlist < 0 && nabnsb > 0) ||
+	   (ir->nstlist == 0 && bGStat))) {
+	/* Store the pressure in t_state for pressure coupling
+	 * at the next MD step.
+	 */
+	copy_mat(pres,state->pres_prev);
+      }
+
+      /* Check for excessively large energies */
+      if (bIonize) {
+#ifdef GMX_DOUBLE
+	real etot_max = 1e200;
+#else
+	real etot_max = 1e30;
+#endif
+	if (fabs(enerd->term[F_ETOT]) > etot_max) {
+	  fprintf(stderr,"Energy too large (%g), giving up\n",
+		  enerd->term[F_ETOT]);
+	  break;
+	}
+      }
+    }
+    
+    /* The coordinates (x) were unshifted in update */
+    if (bFFscan && (shellfc==NULL || bConverged)) {
+      if (print_forcefield(fplog,enerd->term,mdatoms->homenr,f,buf,xcopy,
+			   &(top_global->mols),mdatoms->massT,pres)) {
+	if (gmx_parallel_env)
+	  gmx_finalize(cr);
+	fprintf(stderr,"\n");
+	exit(0);
+      }
+    }
+    
+    if (bTCR) {
+      /* Only do GCT when the relaxation of shells (minimization) has converged,
+       * otherwise we might be coupling to bogus energies. 
+       * In parallel we must always do this, because the other sims might
+       * update the FF.
+       */
+      
+      /* Since this is called with the new coordinates state->x, I assume
+       * we want the new box state->box too. / EL 20040121
+       */
+      do_coupling(fplog,nfile,fnm,tcr,t,step,enerd->term,fr,
+		  ir,MASTER(cr),
+		  mdatoms,&(top->idef),mu_aver,
+		  top_global->mols.nr,cr,
+		  state->box,total_vir,pres,
+		  mu_tot,state->x,f,bConverged);
+      debug_gmx();
+    }
+
+    /* Time for performance */
+    if (((step % stepout) == 0) || bLastStep)
+      update_time();
+
+    /* Output stuff */
+    if (MASTER(cr)) {
+      bool do_dr,do_or;
+      
+      /* If we do reruns, the step numbers in the output energy frames
+       * cannot be used for averages (since energies are only calculated
+       * for trajectory frames).
+       */
+       upd_mdebin(mdebin,fp_dgdl,bGStatEveryStep && !bRerunMD,
+		 mdatoms->tmass,step_ene,t,enerd,state,lastbox,
+		 shake_vir,force_vir,total_vir,pres,
+		 ekind,mu_tot,constr);
+      
+      do_dr  = do_per_step(step,ir->nstdisreout);
+      do_or  = do_per_step(step,ir->nstorireout);
+      
+      print_ebin(fp_ene,do_ene,do_dr,do_or,do_log?fplog:NULL,step,step_ene,t,
+		 eprNORMAL,bCompact,mdebin,fcd,groups,&(ir->opts));
+      
+      if (ir->ePull != epullNO)
+	{
+	  pull_print_output(ir->pull,step,t);
+	}
+      
+      if (do_per_step(step,ir->nstlog))
+	{
+		if(fflush(fplog) != 0)
+		{
+			gmx_fatal(FARGS,"Cannot flush logfile - maybe you are out of quota?");
+		}
+	}
+    }
+    
+    
+    /* Remaining runtime */
+    if (MULTIMASTER(cr) && do_verbose) {
+      if (shellfc)
+	fprintf(stderr,"\n");
+      print_time(stderr,start_t,step,ir);
+    }
+
+    /* Replica exchange */
+    bExchanged = FALSE;
+    if ((repl_ex_nst > 0) && (step > 0) && !bLastStep &&
+	do_per_step(step,repl_ex_nst))
+      bExchanged = replica_exchange(fplog,cr,repl_ex,state_global,enerd->term,
+				    state,step,t);
+    if (bExchanged && PAR(cr)) {
+      if (DOMAINDECOMP(cr)) {
+	dd_partition_system(fplog,step,cr,TRUE,
+			    state_global,top_global,ir,
+			    state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
+			    nrnb,wcycle,FALSE);
+      } else {
+	bcast_state(cr,state,FALSE);
+      }
+    }
+    
+    bFirstStep = FALSE;
+    
+    if (bRerunMD) 
+      /* read next frame from input trajectory */
+      bNotLastFrame = read_next_frame(status,&rerun_fr);
+
+    if (!bRerunMD || !rerun_fr.bStep) {
+      /* increase the MD step number */
+      step++;
+      step_rel++;
+    }
+
+    cycles = wallcycle_stop(wcycle,ewcSTEP);
+    if (DOMAINDECOMP(cr) && wcycle)
+      dd_cycles_add(cr->dd,cycles,ddCyclStep);
+  }
+  /* End of main MD loop */
+  debug_gmx();
+
+  if (bRerunMD)
+    close_trj(status);
+
+  if (!(cr->duty & DUTY_PME)) {
+    /* Tell the PME only node to finish */
+    gmx_pme_finish(cr);
+  }
+	
+  if (MASTER(cr)) {
+    if (bGStatEveryStep && !bRerunMD) {
+      print_ebin(fp_ene,FALSE,FALSE,FALSE,fplog,step,step_ene,t,
+		 eprAVER,FALSE,mdebin,fcd,groups,&(ir->opts));
+      print_ebin(fp_ene,FALSE,FALSE,FALSE,fplog,step,step_ene,t,
+		 eprRMS,FALSE,mdebin,fcd,groups,&(ir->opts));
+    }
+    close_enx(fp_ene);
+    if (ir->nstxtcout)
+      close_xtc(fp_xtc);
+    close_trn(fp_trn);
+    if (fp_dgdl)
+      gmx_fio_fclose(fp_dgdl);
+    if (fp_field)
+      gmx_fio_fclose(fp_field);
+  }
+  debug_gmx();
+  
+  if (ir->nstlist == -1 && nns>0 && fplog) {
+    fprintf(fplog,"Average neighborlist lifetime: %.1f steps, std.dev.: %.1f steps\n",ns_s1/nns,sqrt(ns_s2/nns - sqr(ns_s1/nns)));
+    fprintf(fplog,"Average number of atoms that crossed the half buffer length: %.1f\n\n",ns_ab/nns);
   }
- 
-  /* Some timing stats */  
-  if (MASTER(cr)) {
-    realtime=difftime(time(NULL),start_t);
-    if ((nodetime=node_time()) == 0)
-      nodetime=realtime;
+
+  if (shellfc && fplog) {
+    fprintf(fplog,"Fraction of iterations that converged:           %.2f %%\n",
+	    (nconverged*100.0)/step_rel);
+    fprintf(fplog,"Average number of force evaluations per MD step: %.2f\n\n",
+	    tcount/step_rel);
   }
-  else 
-    realtime=0;
 
-  wallcycle_stop(wcycle,ewcRUN);
-    
-  /* Finish up, write some stuff
-   * if rerunMD, don't write last frame again 
-   */
-  finish_run(fplog,cr,ftp2fn(efSTO,nfile,fnm),
-	     inputrec,nrnb,wcycle,nodetime,realtime,nsteps_done,
-	     EI_DYNAMICS(inputrec->eI) && !MULTISIM(cr));
-  
-  /* Does what it says */  
-  print_date_and_time(fplog,cr->nodeid,"Finished mdrun");
+  if (repl_ex_nst > 0 && MASTER(cr)) {
+    print_replica_exchange_statistics(fplog,repl_ex);
+  }
 
-	/* Close logfile already here if we were appending to it */
-	if (MASTER(cr) && (Flags & MD_APPENDFILES))
-	{
-		gmx_log_close(fplog);
-	}	
+  *nsteps_done = step_rel;
+    
+  return start_t;
 }
 
-time_t do_md(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
-	     bool bVerbose,bool bCompact,
-	     gmx_vsite_t *vsite,gmx_constr_t constr,
-	     int stepout,t_inputrec *ir,
-	     gmx_mtop_t *top_global,
-	     t_fcdata *fcd,
-	     t_state *state_global,rvec f[],
-	     rvec buf[],t_mdatoms *mdatoms,
-	     t_nrnb *nrnb,gmx_wallcycle_t wcycle,
-	     gmx_edsam_t ed,t_forcerec *fr,
-	     int repl_ex_nst,int repl_ex_seed,
-	     real cpt_period,real max_hours,
-	     unsigned long Flags,
-	     int *nsteps_done)
+time_t do_hybrid(FILE *fplog,t_commrec *cr,int nfile,t_filenm fnm[],
+                 bool bVerbose,bool bCompact,
+                 gmx_vsite_t *vsite,gmx_constr_t constr,
+                 int stepout,t_inputrec *ir,
+                 gmx_mtop_t *top_global,
+                 t_fcdata *fcd,
+                 t_state *state_global,rvec f[],
+                 rvec buf[],t_mdatoms *mdatoms,
+                 t_nrnb *nrnb,gmx_wallcycle_t wcycle,
+                 gmx_edsam_t ed,t_forcerec *fr,
+                 int repl_ex_nst,int repl_ex_seed,
+                 real cpt_period,real max_hours,
+                 unsigned long Flags,
+                 int *nsteps_done,t_mdebin **mdbn,
+                 rvec *xsave,rvec *vsave)
 {
   int        fp_ene=0,fp_trn=0,fp_xtc=0,step,step_rel,step_ene;
   char       *fn_cpt;
@@ -494,10 +2351,11 @@
   bool       bNS,bSimAnn,bStopCM,bRerunMD,bNotLastFrame=FALSE,
              bFirstStep,bStateFromTPX,bLastStep;
   bool       bNEMD,do_ene,do_log,do_verbose,bRerunWarnNoV=TRUE,
-	         bForceUpdate=FALSE,bX,bV,bF,bXTC,bCPT;
+                 bForceUpdate=FALSE,bX,bV,bF,bXTC,bCPT;
   bool       bMasterState;
   tensor     force_vir,shake_vir,total_vir,pres,ekin;
   int        i,m,status;
+  int        j,index;
   rvec       mu_tot;
   t_vcm      *vcm;
   int        step_ns=0,step_nscheck=0,nns=0,nabnsb=0,ns_lt;
@@ -509,7 +2367,7 @@
   /* Booleans (disguised as a reals) to checkpoint and terminate mdrun */  
   real       chkpt=0,terminate=0,terminate_now=0;
 
-  gmx_localtop_t *top;	
+  gmx_localtop_t *top;
   t_mdebin *mdebin=NULL;
   t_state    *state=NULL;
   rvec       *f_global=NULL;
@@ -543,7 +2401,7 @@
   bFFscan  = (Flags & MD_FFSCAN);
   bGStatEveryStep = !(Flags & MD_NOGSTAT);
   bAppend  = (Flags & MD_APPENDFILES);
-	
+  
   if (!bGStatEveryStep && !EI_DYNAMICS(ir->eI)) {
     char *warn="\nWARNING:\nNo energy summing can only be used with dynamics, ignoring this option\n";
     fprintf(stderr,"%s\n",warn);
@@ -551,39 +2409,40 @@
       fprintf(fplog,"%s\n",warn);
     bGStatEveryStep = TRUE;
   }
+
   if (!bGStatEveryStep) {
     if (fplog) {
       fprintf(fplog,"\nWill not sum the energies at every step,\n"
-	      "therefore the energy file does not contain exact averages and fluctuations.\n\n");
+              "therefore the energy file does not contain exact averages and fluctuations.\n\n");
       if (ir->etc != etcNO || ir->epc != epcNO) {
-	fprintf(fplog,"WARNING:\nThe temperature and/or pressure for scaling will only be updated every nstlist (%d) steps\n\n",ir->nstlist);
+        fprintf(fplog,"WARNING:\nThe temperature and/or pressure for scaling will only be updated every nstlist (%d) steps\n\n",ir->nstlist);
       }
       if (ir->nstlist == -1) {
-	fprintf(fplog,
-		"To reduce the energy communication with nstlist = -1\n"
-		"the neighbor list validity should not be checked at every step,\n"
-		"this means that exact integration is not guaranteed.\n"
-		"The neighbor list validity is checked after:\n"
-		"  <n.list life time> - 2*std.dev.(n.list life time)  steps.\n"
-		"In most cases this will result in exact integration.\n"
-		"This reduces the energy communication by a factor of 2 to 3.\n"
-		"If you want less energy communication, set nstlist > 3.\n\n");
+        fprintf(fplog,
+                "To reduce the energy communication with nstlist = -1\n"
+                "the neighbor list validity should not be checked at every step,\n"
+                "this means that exact integration is not guaranteed.\n"
+                "The neighbor list validity is checked after:\n"
+                "  <n.list life time> - 2*std.dev.(n.list life time)  steps.\n"
+                "In most cases this will result in exact integration.\n"
+                "This reduces the energy communication by a factor of 2 to 3.\n"
+                "If you want less energy communication, set nstlist > 3.\n\n");
       }
     }
     if (ir->comm_mode != ecmNO && ir->nstcomm == 1) {
       if (fplog) {
-	fprintf(fplog,"WARNING:\nWe should not remove the COM motion every step with option -nosum,\n");
+        fprintf(fplog,"WARNING:\nWe should not remove the COM motion every step with option -nosum,\n");
       }
       if (ir->nstlist > 0) {
-	ir->nstcomm = ir->nstlist;
-	if (fplog) {
-	  fprintf(fplog,"setting nstcomm to nstlist (%d)\n\n",ir->nstcomm);
-	}
+        ir->nstcomm = ir->nstlist;
+        if (fplog) {
+          fprintf(fplog,"setting nstcomm to nstlist (%d)\n\n",ir->nstcomm);
+        }
       } else {
-	ir->nstcomm = 100;
-	if (fplog) {
-	  fprintf(fplog,"setting nstcomm to %d\n\n",ir->nstcomm);
-	}
+        ir->nstcomm = 100;
+        if (fplog) {
+          fprintf(fplog,"setting nstcomm to %d\n\n",ir->nstcomm);
+        }
       }
     }
   }
@@ -595,10 +2454,11 @@
 
   /* Initial values */
   init_md(fplog,cr,ir,&t,&t0,&state_global->lambda,&lam0,
-	  nrnb,top_global,&sd,
-	  nfile,fnm,&fp_trn,&fp_xtc,&fp_ene,&fn_cpt,
-	  &fp_dgdl,&fp_field,&mdebin,
-	  force_vir,shake_vir,mu_tot,&bNEMD,&bSimAnn,&vcm,Flags);
+          nrnb,top_global,&sd,
+          nfile,fnm,&fp_trn,&fp_xtc,&fp_ene,&fn_cpt,
+          &fp_dgdl,&fp_field,mdbn,
+          force_vir,shake_vir,mu_tot,&bNEMD,&bSimAnn,&vcm,Flags);
+  mdebin = *mdbn;
 
   /* Energy terms and groups */
   snew(enerd,1);
@@ -613,17 +2473,17 @@
 
   /* Check for polarizable models and flexible constraints */
   shellfc = init_shell_flexcon(fplog,
-			       top_global,n_flexible_constraints(constr),
-			       (ir->bContinuation || 
-				(DOMAINDECOMP(cr) && !MASTER(cr))) ?
-			       NULL : state_global->x);
+                               top_global,n_flexible_constraints(constr),
+                               (ir->bContinuation || 
+                                (DOMAINDECOMP(cr) && !MASTER(cr))) ?
+                               NULL : state_global->x);
 
   {
     double io = compute_io(ir,top_global->natoms,groups,mdebin->ebin->nener,1);
     if ((io > 2000) && MASTER(cr))
       fprintf(stderr,
-	      "\nWARNING: This run will generate roughly %.0f Mb of data\n\n",
-	      io);
+              "\nWARNING: This run will generate roughly %.0f Mb of data\n\n",
+              io);
   }
  
   if (DOMAINDECOMP(cr)) {
@@ -674,9 +2534,9 @@
   if (DOMAINDECOMP(cr)) {
     /* Distribute the charge groups over the nodes from the master node */
     dd_partition_system(fplog,ir->init_step,cr,TRUE,
-			state_global,top_global,ir,
-			state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
-			nrnb,wcycle,FALSE);
+                        state_global,top_global,ir,
+                        state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
+                        nrnb,wcycle,FALSE);
   }
 
   update_mdatoms(mdatoms,state->lambda);
@@ -690,9 +2550,9 @@
     }
     /* Set the initial energy history in state to zero by updating once */
     update_energyhistory(&state_global->enerhist,mdebin);
-  }	
-	
-	
+  }     
+        
+        
   if (sd && (Flags & MD_READ_RNG)) {
     /* Set the random state if we read a checkpoint file */
     set_stochd_state(sd,state);
@@ -721,7 +2581,7 @@
 
   if (repl_ex_nst > 0 && MASTER(cr)) {
     repl_ex = init_replica_exchange(fplog,cr->ms,state_global,ir,
-				    repl_ex_nst,repl_ex_seed);
+                                    repl_ex_nst,repl_ex_seed);
 
     if (max_hours > 0 && MASTERSIM(cr->ms)) {
       fprintf(stderr,"\nWARNING: Using -maxh with REMD can cause the simulation to hang after maxh hours\n\n");
@@ -764,19 +2624,19 @@
       if (ekind->cosacc.cos_accel == 0) {
           calc_ke_part(state->v,&(ir->opts),mdatoms,ekind,nrnb,state->lambda);
       } else {
-	  calc_ke_part_visc(state->box,state->x,state->v,&(ir->opts),
-			    mdatoms,ekind,nrnb,state->lambda);
+          calc_ke_part_visc(state->box,state->x,state->v,&(ir->opts),
+                            mdatoms,ekind,nrnb,state->lambda);
       }
       debug_gmx();
 
       if (PAR(cr))
       {
-	  GMX_MPE_LOG(ev_global_stat_start);
-	  
-	  global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
-		      ir,ekind,FALSE,constr,vcm,NULL,NULL,&terminate);
-	  
-	  GMX_MPE_LOG(ev_global_stat_finish);
+          GMX_MPE_LOG(ev_global_stat_start);
+          
+          global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
+                      ir,ekind,FALSE,constr,vcm,NULL,NULL,&terminate);
+          
+          GMX_MPE_LOG(ev_global_stat_finish);
       }
        debug_gmx();
   }
@@ -785,7 +2645,16 @@
   temp0 = sum_ekin(TRUE,&(ir->opts),ekind,ekin,NULL);
 
   debug_gmx();
-   
+  
+  /* Initiate data for the special cases */ 
+  if(ir->nsteps==0)
+  {
+      for(ii=0; (ii<state->natoms); ii++)
+        {
+            copy_rvec(state->x[ii],xsave[ii]);
+            copy_rvec(state->v[ii],vsave[ii]);
+        }
+  }
   /* Initiate data for the special cases */
   if (bFFscan) {
     snew(xcopy,state->natoms);
@@ -800,29 +2669,29 @@
   if (MASTER(cr)) {
     if (constr && !ir->bContinuation && ir->eConstrAlg == econtLINCS)
       fprintf(fplog,
-	      "RMS relative constraint deviation after constraining: %.2e\n",
-	      constr_rmsd(constr,FALSE));
+              "RMS relative constraint deviation after constraining: %.2e\n",
+              constr_rmsd(constr,FALSE));
     fprintf(fplog,"Initial temperature: %g K\n",temp0);
     if (bRerunMD) {
       fprintf(stderr,"starting md rerun '%s', reading coordinates from"
-	      " input trajectory '%s'\n\n",
-	      *(top_global->name),opt2fn("-rerun",nfile,fnm));
+              " input trajectory '%s'\n\n",
+              *(top_global->name),opt2fn("-rerun",nfile,fnm));
       if (bVerbose)
-	fprintf(stderr,"Calculated time to finish depends on nsteps from "
-		"run input file,\nwhich may not correspond to the time "
-		"needed to process input trajectory.\n\n");
+        fprintf(stderr,"Calculated time to finish depends on nsteps from "
+                "run input file,\nwhich may not correspond to the time "
+                "needed to process input trajectory.\n\n");
     } else {
-		if(ir->init_step>0)
-		{
-			fprintf(stderr,"starting mdrun '%s'\n%d steps, %8.1f ps (continuing from step %d, %8.1f ps).\n",
-					*(top_global->name),ir->nsteps+ir->init_step,(ir->nsteps+ir->init_step)*ir->delta_t,
-					ir->init_step,ir->init_step*ir->delta_t);
-		}
-		else
-		{
-			fprintf(stderr,"starting mdrun '%s'\n%d steps, %8.1f ps.\n",
-					*(top_global->name),ir->nsteps,ir->nsteps*ir->delta_t);
-		}
+                if(ir->init_step>0)
+                {
+                        fprintf(stderr,"starting mdrun '%s'\n%d steps, %8.1f ps (continuing from step %d, %8.1f ps).\n",
+                                        *(top_global->name),ir->nsteps+ir->init_step,(ir->nsteps+ir->init_step)*ir->delta_t,
+                                        ir->init_step,ir->init_step*ir->delta_t);
+                }
+                else
+                {
+                        fprintf(stderr,"starting mdrun '%s'\n%d steps, %8.1f ps.\n",
+                                        *(top_global->name),ir->nsteps,ir->nsteps*ir->delta_t);
+                }
     }
     fprintf(fplog,"\n");
   }
@@ -854,15 +2723,15 @@
       bForceUpdate = TRUE;
 
     bNotLastFrame = read_first_frame(&status,opt2fn("-rerun",nfile,fnm),
-				     &rerun_fr,TRX_NEED_X | TRX_READ_V);
+                                     &rerun_fr,TRX_NEED_X | TRX_READ_V);
     if (rerun_fr.natoms != top_global->natoms)
       gmx_fatal(FARGS,"Number of atoms in trajectory (%d) does not match the "
-		"run input file (%d)\n",rerun_fr.natoms,top_global->natoms);
+                "run input file (%d)\n",rerun_fr.natoms,top_global->natoms);
     if (ir->ePBC != epbcNONE) {
       if (!rerun_fr.bBox)
-	gmx_fatal(FARGS,"Rerun trajectory frame step %d time %f does not contain a box, while pbc is used",rerun_fr.step,rerun_fr.time);
+        gmx_fatal(FARGS,"Rerun trajectory frame step %d time %f does not contain a box, while pbc is used",rerun_fr.step,rerun_fr.time);
       if (max_cutoff2(ir->ePBC,rerun_fr.box) < sqr(fr->rlistlong))
-	gmx_fatal(FARGS,"Rerun trajectory frame step %d time %f has too small box dimensions",rerun_fr.step,rerun_fr.time);
+        gmx_fatal(FARGS,"Rerun trajectory frame step %d time %f has too small box dimensions",rerun_fr.step,rerun_fr.time);
 
       /* Set the shift vectors.
        * Necessary here when have a static box different from the tpr box.
@@ -892,13 +2761,13 @@
 
     if (bRerunMD) {
       if (rerun_fr.bStep) {
-	step = rerun_fr.step;
-	step_rel = step - ir->init_step;
+        step = rerun_fr.step;
+        step_rel = step - ir->init_step;
       }
       if (rerun_fr.bTime)
-	t = rerun_fr.time;
+        t = rerun_fr.time;
       else
-	t = step;
+        t = step;
     } else {
       bLastStep = (step_rel == ir->nsteps);
 
@@ -910,134 +2779,134 @@
       step_ene = step_rel;
     }
 
-    if (ir->efep != efepNO) {
-      if (bRerunMD && rerun_fr.bLambda && (ir->delta_lambda!=0))
-	state_global->lambda = rerun_fr.lambda;
-      else
-	state_global->lambda = lam0 + step*ir->delta_lambda;
-      state->lambda = state_global->lambda;
-    }
-    
-    if (bSimAnn) 
-      update_annealing_target_temp(&(ir->opts),t);
-    
-    if (bRerunMD) {
-      if (!(DOMAINDECOMP(cr) && !MASTER(cr))) {
-	for(i=0; i<state_global->natoms; i++) {
-	  copy_rvec(rerun_fr.x[i],state_global->x[i]);
-	}
-	if (rerun_fr.bV) {
-	  for(i=0; i<state_global->natoms; i++) {
-	    copy_rvec(rerun_fr.v[i],state_global->v[i]);
-	  }
-	} else {
-	  for(i=0; i<state_global->natoms; i++) {
-	    clear_rvec(state_global->v[i]);
-	  }
-	  if (bRerunWarnNoV) {
-	    fprintf(stderr,"\nWARNING: Some frames do not contain velocities.\n"
-		    "         Ekin, temperature and pressure are incorrect,\n"
-		    "         the virial will be incorrect when constraints are present.\n"
-		    "\n");
-	    bRerunWarnNoV = FALSE;
-	  }
-	}
-      }
-      copy_mat(rerun_fr.box,state_global->box);
-      copy_mat(state_global->box,state->box);
-
-      if (vsite && (Flags & MD_RERUN_VSITE)) {
-	if (DOMAINDECOMP(cr)) {
-	  gmx_fatal(FARGS,"Vsite recalculation with -rerun is not implemented for domain decomposition, use particle decomposition");
-	}
-	if (graph) {
-	  /* Following is necessary because the graph may get out of sync
-	   * with the coordinates if we only have every N'th coordinate set
-	   */
-	  mk_mshift(fplog,graph,fr->ePBC,state->box,state->x);
-	  shift_self(graph,state->box,state->x);
-	}
-	construct_vsites(fplog,vsite,state->x,nrnb,ir->delta_t,state->v,
-			 top->idef.iparams,top->idef.il,
-			 fr->ePBC,fr->bMolPBC,graph,cr,state->box);
-	if (graph)
-	  unshift_self(graph,state->box,state->x);
-      }
-    }
-
-    /* Stop Center of Mass motion */
-    bStopCM = (ir->comm_mode != ecmNO && do_per_step(step,ir->nstcomm));
-
-    /* Copy back starting coordinates in case we're doing a forcefield scan */
-    if (bFFscan) {
-      for(ii=0; (ii<state->natoms); ii++) {
-	copy_rvec(xcopy[ii],state->x[ii]);
-	copy_rvec(vcopy[ii],state->v[ii]);
-      }
-      copy_mat(boxcopy,state->box);
-    }
-    
-    bNS = bFirstStep;
-    if (bRerunMD) {
-      /* for rerun MD always do Neighbour Searching */
-      if (ir->nstlist != 0) {
-	bNS = TRUE;
-      }
-    } else {
-      /* Determine whether or not to do Neighbour Searching */
-      if (bExchanged || (ir->nstlist > 0 && (step % ir->nstlist == 0))) {
-	bNS = TRUE;
-      } else if (ir->nstlist == -1) {
-	bNS = (bFirstStep || nabnsb > 0);
-	if (bNS) {
-	  if (bFirstStep) {
-	    ns_lt_runav = 0;
-	    step_nscheck = step;
-	  } else {
-	    /* Determine the neighbor list life time */
-	    ns_lt = step - step_ns;
-	    if (debug) {
-	      fprintf(debug,"%d atoms beyond ns buffer, updating neighbor list after %d steps\n",nabnsb,ns_lt);
-	    }
-	    nns++;
-	    ns_s1 += ns_lt;
-	    ns_s2 += ns_lt*ns_lt;
-	    ns_ab += nabnsb;
-	    if (ns_lt_runav == 0) {
-	      ns_lt_runav  = ns_lt;
-	      /* Initialize the fluctuation average such that at startup
-	       * we check after 0 steps.
-	       */
-	      ns_lt_runav2 = sqr(ns_lt/2.0);
-	    }
-	    /* Running average with 0.9 gives an exp. history of 9.5 */
-	    ns_lt_runav2 = 0.9*ns_lt_runav2 + 0.1*sqr(ns_lt_runav - ns_lt);
-	    ns_lt_runav  = 0.9*ns_lt_runav  + 0.1*ns_lt;
-	    if (bGStatEveryStep) {
-	      /* Always check the nlist validity */
-	      step_nscheck = step;
-	    } else {
-	      /* We check after:  <life time> - 2*sigma
-	       * The factor 2 is quite conservative,
-	       * but we assume that with nstlist=-1 the user prefers
-	       * exact integration over performance.
-	       */
-	      step_nscheck = step
-		+ (int)(ns_lt_runav - 2.0*sqrt(ns_lt_runav2)) - 1;
-	    }
-	    if (debug) {
-	      fprintf(debug,"nlist life time %d run av. %4.1f sig %3.1f check %d check with -nosum %d\n",
-		      ns_lt,ns_lt_runav,sqrt(ns_lt_runav2),
-		      step_nscheck-step+1,
-		      (int)(ns_lt_runav - 2.0*sqrt(ns_lt_runav2)));
-	    }
-	  }
-	  step_ns = step;
-	  /* Initialize the cumulative coordinate scaling matrix */
-	  clear_mat(*scale_tot);
-	  for(ii=0; ii<DIM; ii++)
-	    (*scale_tot)[ii][ii] = 1.0;
-	}
+    if (ir->efep != efepNO) {
+      if (bRerunMD && rerun_fr.bLambda && (ir->delta_lambda!=0))
+        state_global->lambda = rerun_fr.lambda;
+      else
+        state_global->lambda = lam0 + step*ir->delta_lambda;
+      state->lambda = state_global->lambda;
+    }
+    
+    if (bSimAnn) 
+      update_annealing_target_temp(&(ir->opts),t);
+    
+    if (bRerunMD) {
+      if (!(DOMAINDECOMP(cr) && !MASTER(cr))) {
+        for(i=0; i<state_global->natoms; i++) {
+          copy_rvec(rerun_fr.x[i],state_global->x[i]);
+        }
+        if (rerun_fr.bV) {
+          for(i=0; i<state_global->natoms; i++) {
+            copy_rvec(rerun_fr.v[i],state_global->v[i]);
+          }
+        } else {
+          for(i=0; i<state_global->natoms; i++) {
+            clear_rvec(state_global->v[i]);
+          }
+          if (bRerunWarnNoV) {
+            fprintf(stderr,"\nWARNING: Some frames do not contain velocities.\n"
+                    "         Ekin, temperature and pressure are incorrect,\n"
+                    "         the virial will be incorrect when constraints are present.\n"
+                    "\n");
+            bRerunWarnNoV = FALSE;
+          }
+        }
+      }
+      copy_mat(rerun_fr.box,state_global->box);
+      copy_mat(state_global->box,state->box);
+
+      if (vsite && (Flags & MD_RERUN_VSITE)) {
+        if (DOMAINDECOMP(cr)) {
+          gmx_fatal(FARGS,"Vsite recalculation with -rerun is not implemented for domain decomposition, use particle decomposition");
+        }
+        if (graph) {
+          /* Following is necessary because the graph may get out of sync
+           * with the coordinates if we only have every N'th coordinate set
+           */
+          mk_mshift(fplog,graph,fr->ePBC,state->box,state->x);
+          shift_self(graph,state->box,state->x);
+        }
+        construct_vsites(fplog,vsite,state->x,nrnb,ir->delta_t,state->v,
+                         top->idef.iparams,top->idef.il,
+                         fr->ePBC,fr->bMolPBC,graph,cr,state->box);
+        if (graph)
+          unshift_self(graph,state->box,state->x);
+      }
+    }
+
+    /* Stop Center of Mass motion */
+    bStopCM = (ir->comm_mode != ecmNO && do_per_step(step,ir->nstcomm));
+
+    /* Copy back starting coordinates in case we're doing a forcefield scan */
+    if (bFFscan) {
+      for(ii=0; (ii<state->natoms); ii++) {
+        copy_rvec(xcopy[ii],state->x[ii]);
+        copy_rvec(vcopy[ii],state->v[ii]);
+      }
+      copy_mat(boxcopy,state->box);
+    }
+    
+    bNS = bFirstStep;
+    if (bRerunMD) {
+      /* for rerun MD always do Neighbour Searching */
+      if (ir->nstlist != 0) {
+        bNS = TRUE;
+      }
+    } else {
+      /* Determine whether or not to do Neighbour Searching */
+      if (bExchanged || (ir->nstlist > 0 && (step % ir->nstlist == 0))) {
+        bNS = TRUE;
+      } else if (ir->nstlist == -1) {
+        bNS = (bFirstStep || nabnsb > 0);
+        if (bNS) {
+          if (bFirstStep) {
+            ns_lt_runav = 0;
+            step_nscheck = step;
+          } else {
+            /* Determine the neighbor list life time */
+            ns_lt = step - step_ns;
+            if (debug) {
+              fprintf(debug,"%d atoms beyond ns buffer, updating neighbor list after %d steps\n",nabnsb,ns_lt);
+            }
+            nns++;
+            ns_s1 += ns_lt;
+            ns_s2 += ns_lt*ns_lt;
+            ns_ab += nabnsb;
+            if (ns_lt_runav == 0) {
+              ns_lt_runav  = ns_lt;
+              /* Initialize the fluctuation average such that at startup
+               * we check after 0 steps.
+               */
+              ns_lt_runav2 = sqr(ns_lt/2.0);
+            }
+            /* Running average with 0.9 gives an exp. history of 9.5 */
+            ns_lt_runav2 = 0.9*ns_lt_runav2 + 0.1*sqr(ns_lt_runav - ns_lt);
+            ns_lt_runav  = 0.9*ns_lt_runav  + 0.1*ns_lt;
+            if (bGStatEveryStep) {
+              /* Always check the nlist validity */
+              step_nscheck = step;
+            } else {
+              /* We check after:  <life time> - 2*sigma
+               * The factor 2 is quite conservative,
+               * but we assume that with nstlist=-1 the user prefers
+               * exact integration over performance.
+               */
+              step_nscheck = step
+                + (int)(ns_lt_runav - 2.0*sqrt(ns_lt_runav2)) - 1;
+            }
+            if (debug) {
+              fprintf(debug,"nlist life time %d run av. %4.1f sig %3.1f check %d check with -nosum %d\n",
+                      ns_lt,ns_lt_runav,sqrt(ns_lt_runav2),
+                      step_nscheck-step+1,
+                      (int)(ns_lt_runav - 2.0*sqrt(ns_lt_runav2)));
+            }
+          }
+          step_ns = step;
+          /* Initialize the cumulative coordinate scaling matrix */
+          clear_mat(*scale_tot);
+          for(ii=0; ii<DIM; ii++)
+            (*scale_tot)[ii][ii] = 1.0;
+        }
       }
     } 
 
@@ -1050,26 +2919,26 @@
 
     if (bNS && !(bFirstStep && ir->bContinuation && !bRerunMD)) {
       if (bRerunMD) {
-	bMasterState = TRUE;
+        bMasterState = TRUE;
       } else {
-	bMasterState = FALSE;
-	/* Correct the new box if it is too skewed */
-	if (DYNAMIC_BOX(*ir)) {
-	  if (correct_box(fplog,step,state->box,graph))
-	    bMasterState = TRUE;
-	}
-	if (DOMAINDECOMP(cr) && bMasterState)
-	  dd_collect_state(cr->dd,state,state_global);
+        bMasterState = FALSE;
+        /* Correct the new box if it is too skewed */
+        if (DYNAMIC_BOX(*ir)) {
+          if (correct_box(fplog,step,state->box,graph))
+            bMasterState = TRUE;
+        }
+        if (DOMAINDECOMP(cr) && bMasterState)
+          dd_collect_state(cr->dd,state,state_global);
       }
       
       if (DOMAINDECOMP(cr)) {
-	/* Repartition the domain decomposition */
-	wallcycle_start(wcycle,ewcDOMDEC);
-	dd_partition_system(fplog,step,cr,bMasterState,
-			    state_global,top_global,ir,
-			    state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
-			    nrnb,wcycle,do_verbose);
-	wallcycle_stop(wcycle,ewcDOMDEC);
+        /* Repartition the domain decomposition */
+        wallcycle_start(wcycle,ewcDOMDEC);
+        dd_partition_system(fplog,step,cr,bMasterState,
+                            state_global,top_global,ir,
+                            state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
+                            nrnb,wcycle,do_verbose);
+        wallcycle_stop(wcycle,ewcDOMDEC);
       }
     }
 
@@ -1085,8 +2954,8 @@
        */
       calc_ke_part(state->v,&(ir->opts),mdatoms,ekind,nrnb,state->lambda);
       if (PAR(cr)) {
-	global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
-		    ir,ekind,FALSE,constr,vcm,NULL,NULL,&terminate);
+        global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
+                    ir,ekind,FALSE,constr,vcm,NULL,NULL,&terminate);
       }
       sum_ekin(FALSE,&(ir->opts),ekind,ekin,NULL);
     }
@@ -1096,16 +2965,16 @@
     /* Ionize the atoms if necessary */
     if (bIonize) {
       ionize(fplog,mdatoms,top_global,t,ir,state->x,state->v,
-	     mdatoms->start,mdatoms->start+mdatoms->homenr,state->box,cr);
+             mdatoms->start,mdatoms->start+mdatoms->homenr,state->box,cr);
     }
       
     /* Update force field in ffscan program */
     if (bFFscan) {
       if (update_forcefield(fplog,
-			    nfile,fnm,fr,mdatoms->nr,state->x,state->box)) {
-	if (gmx_parallel_env)
-	  gmx_finalize(cr);
-	exit(0);
+                            nfile,fnm,fr,mdatoms->nr,state->x,state->box)) {
+        if (gmx_parallel_env)
+          gmx_finalize(cr);
+        exit(0);
       }
     }
 
@@ -1114,16 +2983,16 @@
     if (shellfc) {
       /* Now is the time to relax the shells */
       count=relax_shell_flexcon(fplog,cr,bVerbose,bFFscan ? step+1 : step,
-				ir,bNS,bStopCM,top,constr,enerd,fcd,
-				state,f,buf,force_vir,mdatoms,
-				nrnb,wcycle,graph,groups,
-				shellfc,fr,t,mu_tot,
-				state->natoms,&bConverged,vsite,
-				fp_field);
+                                ir,bNS,bStopCM,top,constr,enerd,fcd,
+                                state,f,buf,force_vir,mdatoms,
+                                nrnb,wcycle,graph,groups,
+                                shellfc,fr,t,mu_tot,
+                                state->natoms,&bConverged,vsite,
+                                fp_field);
       tcount+=count;
       
       if (bConverged)
-	nconverged++;
+        nconverged++;
     }
     else {
       /* The coordinates (x) are shifted (to get whole molecules) in do_force
@@ -1131,22 +3000,22 @@
        * Check comments in sim_util.c
        */
       do_force(fplog,cr,ir,step,nrnb,wcycle,top,groups,
-	       state->box,state->x,&state->hist,
-	       f,buf,force_vir,mdatoms,enerd,fcd,
-	       state->lambda,graph,
-	       fr,vsite,mu_tot,t,fp_field,ed,
-	       GMX_FORCE_STATECHANGED | (bNS ? GMX_FORCE_NS : 0) |
-	       GMX_FORCE_ALLFORCES);
+               state->box,state->x,&state->hist,
+               f,buf,force_vir,mdatoms,enerd,fcd,
+               state->lambda,graph,
+               fr,vsite,mu_tot,t,fp_field,ed,
+               GMX_FORCE_STATECHANGED | (bNS ? GMX_FORCE_NS : 0) |
+               GMX_FORCE_ALLFORCES);
     }
 
     GMX_BARRIER(cr->mpi_comm_mygroup);
 
     if (bTCR)
       mu_aver = calc_mu_aver(cr,state->x,mdatoms->chargeA,
-			     mu_tot,&top_global->mols,mdatoms,gnx,grpindex);
+                             mu_tot,&top_global->mols,mdatoms,gnx,grpindex);
     if (bGlas)
       do_glas(fplog,mdatoms->start,mdatoms->homenr,state->x,f,
-	      fr,mdatoms,top->idef.atnr,ir,enerd->term);
+              fr,mdatoms,top->idef.atnr,ir,enerd->term);
     
     if (bTCR && bFirstStep) {
       tcr=init_coupling(fplog,nfile,fnm,cr,fr,mdatoms,&(top->idef));
@@ -1168,9 +3037,9 @@
     bXTC = do_per_step(step,ir->nstxtcout);
     if ((bNS || bLastStep) && (step > ir->init_step) && !bRerunMD) {
       bCPT = ((chkpt < 0 && do_per_step(step,ir->nstenergy)) || chkpt > 0 ||
-	       bLastStep);
+               bLastStep);
       if (bCPT) {
-	chkpt = 0;
+        chkpt = 0;
       }
     } else {
       bCPT = FALSE;
@@ -1179,40 +3048,46 @@
     if (bX || bV || bF || bXTC || bCPT) {
       wallcycle_start(wcycle,ewcTRAJ);
       if (bCPT) {
-	if (sd) {
-	  get_stochd_state(sd,state);
-	}
-	if (MASTER(cr)) {
-	  if (bSumEkinhOld) {
-	    state_global->ekinstate.bUpToDate = FALSE;
-	  } else {
-	    update_ekinstate(&state_global->ekinstate,ekind);
-	    state_global->ekinstate.bUpToDate = TRUE;
-	  }
-	  update_energyhistory(&state_global->enerhist,mdebin);
-	}
+        if (sd) {
+          get_stochd_state(sd,state);
+        }
+        if (MASTER(cr)) {
+          if (bSumEkinhOld) {
+            state_global->ekinstate.bUpToDate = FALSE;
+          } else {
+            update_ekinstate(&state_global->ekinstate,ekind);
+            state_global->ekinstate.bUpToDate = TRUE;
+          }
+          update_energyhistory(&state_global->enerhist,mdebin);
+        }
       }
       write_traj(fplog,cr,fp_trn,bX,bV,bF,fp_xtc,bXTC,ir->xtcprec,fn_cpt,bCPT,
-				 top_global,ir->eI,ir->simulation_part,step,t,state,state_global,f,f_global);
+                                 top_global,ir->eI,ir->simulation_part,step,t,state,state_global,f,f_global);
       debug_gmx();
 
       if (bLastStep && step_rel == ir->nsteps &&
-	  (Flags & MD_CONFOUT) && MASTER(cr) &&
-	  !bRerunMD && !bFFscan) {
-	/* x and v have been collected in write_traj */
-	fprintf(stderr,"\nWriting final coordinates.\n");
-	if (ir->ePBC != epbcNONE && !ir->bPeriodicMols && DOMAINDECOMP(cr)) {
-	  /* Make molecules whole only for confout writing */
-	  do_pbc_mtop(fplog,ir->ePBC,state->box,top_global,state_global->x);
-	}
-	write_sto_conf_mtop(ftp2fn(efSTO,nfile,fnm),
-			    *top_global->name,top_global,
-			    state_global->x,state_global->v,
-			    ir->ePBC,state->box);
-	debug_gmx();
+          (Flags & MD_CONFOUT) && MASTER(cr) &&
+          !bRerunMD && !bFFscan) {
+        /* x and v have been collected in write_traj */
+        fprintf(stderr,"\nWriting final coordinates.\n");
+        if (ir->ePBC != epbcNONE && !ir->bPeriodicMols && DOMAINDECOMP(cr)) {
+          /* Make molecules whole only for confout writing */
+          do_pbc_mtop(fplog,ir->ePBC,state->box,top_global,state_global->x);
+        }
+        write_sto_conf_mtop(ftp2fn(efSTO,nfile,fnm),
+                            *top_global->name,top_global,
+                            state_global->x,state_global->v,
+                            ir->ePBC,state->box);
+        for(ii=0; (ii<state->natoms); ii++)
+        {
+            copy_rvec(state->x[ii],xsave[ii]);
+            copy_rvec(state->v[ii],vsave[ii]);
+        }
+        debug_gmx();
       }
       wallcycle_stop(wcycle,ewcTRAJ);
     }
+    
     GMX_MPE_LOG(ev_output_finish);
 
     clear_mat(shake_vir);
@@ -1240,11 +3115,11 @@
        * we should only do it at step % nstlist = 1 with bGStatEveryStep=FALSE.
        */
       update(fplog,step,&dvdl,ir,mdatoms,state,graph,f,buf,fcd,
-	     &top->idef,ekind,shake_vir,scale_tot,
-	     cr,nrnb,wcycle,sd,constr,bHaveConstr,
-	     bNEMD,bFirstStep && bStateFromTPX);
+             &top->idef,ekind,shake_vir,scale_tot,
+             cr,nrnb,wcycle,sd,constr,bHaveConstr,
+             bNEMD,bFirstStep && bStateFromTPX);
       if (fr->bSepDVDL && fplog && do_log) {
-	fprintf(fplog,sepdvdlformat,"Constraint",0.0,dvdl);
+        fprintf(fplog,sepdvdlformat,"Constraint",0.0,dvdl);
       }
       enerd->term[F_DGDL_CON] += dvdl;
       wallcycle_stop(wcycle,ewcUPDATE);
@@ -1262,14 +3137,14 @@
     if (vsite) {
       wallcycle_start(wcycle,ewcVSITECONSTR);
       if (graph)
-	shift_self(graph,state->box,state->x);
+        shift_self(graph,state->box,state->x);
       
       construct_vsites(fplog,vsite,state->x,nrnb,ir->delta_t,state->v,
-		       top->idef.iparams,top->idef.il,
-		       fr->ePBC,fr->bMolPBC,graph,cr,state->box);
+                       top->idef.iparams,top->idef.il,
+                       fr->ePBC,fr->bMolPBC,graph,cr,state->box);
      
       if (graph)
-	unshift_self(graph,state->box,state->x);
+        unshift_self(graph,state->box,state->x);
       wallcycle_stop(wcycle,ewcVSITECONSTR);
     }
 
@@ -1284,7 +3159,7 @@
       calc_ke_part(state->v,&(ir->opts),mdatoms,ekind,nrnb,state->lambda);
     } else {
       calc_ke_part_visc(state->box,state->x,state->v,&(ir->opts),
-			mdatoms,ekind,nrnb,state->lambda);
+                        mdatoms,ekind,nrnb,state->lambda);
     }
 
     /* since we use the new coordinates in calc_ke_part_visc, we should use
@@ -1296,7 +3171,7 @@
     /* Calculate center of mass velocity if necessary, also parallellized */
     if (bStopCM && !bFFscan && !bRerunMD)
       calc_vcm_grp(fplog,mdatoms->start,mdatoms->homenr,mdatoms,
-		   state->x,state->v,vcm);
+                   state->x,state->v,vcm);
     
     /* Determine the wallclock run time up till now */
     run_time = (double)time(NULL) - (double)start_t;
@@ -1304,32 +3179,32 @@
     /* Check whether everything is still allright */    
     if (bGotTermSignal || bGotUsr1Signal) {
       if (bGotTermSignal || ir->nstlist == 0)
-	terminate = 1;
+        terminate = 1;
       else
-	terminate = -1;
+        terminate = -1;
       if (!PAR(cr))
-	terminate_now = terminate;
+        terminate_now = terminate;
       if (fplog) {
-	fprintf(fplog,
-		"\n\nReceived the %s signal, stopping at the next %sstep\n\n",
-		bGotTermSignal ? "TERM" : "USR1",terminate==-1 ? "NS " : "");
-	fflush(fplog);
+        fprintf(fplog,
+                "\n\nReceived the %s signal, stopping at the next %sstep\n\n",
+                bGotTermSignal ? "TERM" : "USR1",terminate==-1 ? "NS " : "");
+        fflush(fplog);
       }
       fprintf(stderr,
-	      "\n\nReceived the %s signal, stopping at the next %sstep\n\n",
-	      bGotTermSignal ? "TERM" : "USR1",terminate==-1 ? "NS " : "");
+              "\n\nReceived the %s signal, stopping at the next %sstep\n\n",
+              bGotTermSignal ? "TERM" : "USR1",terminate==-1 ? "NS " : "");
       fflush(stderr);
       bGotTermSignal = FALSE;
       bGotUsr1Signal = FALSE;
     } else if (MASTER(cr) && (bNS || ir->nstlist <= 0) &&
-	       (max_hours > 0 && run_time > max_hours*60.0*60.0*0.99) &&
-	       terminate == 0) {
+               (max_hours > 0 && run_time > max_hours*60.0*60.0*0.99) &&
+               terminate == 0) {
       /* Signal to terminate the run */
       terminate = (ir->nstlist == 0 ? 1 : -1);
       if (!PAR(cr))
-	terminate_now = terminate;
+        terminate_now = terminate;
      if (fplog)
-	fprintf(fplog,"\nStep %d: Run time exceeded %.3f hours, will terminate the run\n",step,max_hours*0.99);
+        fprintf(fplog,"\nStep %d: Run time exceeded %.3f hours, will terminate the run\n",step,max_hours*0.99);
       fprintf(stderr, "\nStep %d: Run time exceeded %.3f hours, will terminate the run\n",step,max_hours*0.99);
     }
     
@@ -1345,17 +3220,17 @@
        * has been called.
        */
       if (step >= step_nscheck) {
-	nabnsb = natoms_beyond_ns_buffer(ir,fr,&top->cgs,*scale_tot,state->x);
-	bGStat = TRUE;
+        nabnsb = natoms_beyond_ns_buffer(ir,fr,&top->cgs,*scale_tot,state->x);
+        bGStat = TRUE;
       } else {
-	/* This is not necessarily true,
-	 * but step_nscheck is determined quite conservatively.
-	 */
-	nabnsb = 0;
+        /* This is not necessarily true,
+         * but step_nscheck is determined quite conservatively.
+         */
+        nabnsb = 0;
       }
     } else {
       if (bNS) {
-	bGStat = TRUE;
+        bGStat = TRUE;
       }
     }
 
@@ -1363,20 +3238,20 @@
      * where we do global communication, otherwise the other nodes don't know.
      */
     if (MASTER(cr) && ((bGStat || !PAR(cr)) &&
-		       cpt_period >= 0 &&
-		       (cpt_period == 0 || 
-			run_time >= nchkpt*cpt_period*60.0))) {
+                       cpt_period >= 0 &&
+                       (cpt_period == 0 || 
+                        run_time >= nchkpt*cpt_period*60.0))) {
       if (chkpt == 0) {
-	nchkpt++;
+        nchkpt++;
       }
       /* Write checkpoint at the next energy output step (if there is one),
        * or after 0.2*cpt_period at any step.
        */
       if (!bGStatEveryStep || ir->nstenergy == 0 || cpt_period == 0 ||
-	  run_time >= (nchkpt + 0.2)*cpt_period*60.0) {
-	chkpt = 1;
+          run_time >= (nchkpt + 0.2)*cpt_period*60.0) {
+        chkpt = 1;
       } else {
-	chkpt = -1;
+        chkpt = -1;
       }
     }
 
@@ -1389,8 +3264,8 @@
      * the extra first frame in that case.
      */
     do_ene = (do_per_step(step,ir->nstenergy) ||
-	      (bGStatEveryStep && ((bFirstStep && !bAppend) ||
-				   bLastStep || bCPT)));
+              (bGStatEveryStep && ((bFirstStep && !bAppend) ||
+                                   bLastStep || bCPT)));
 
     if (do_ene || do_log) {
       bGStat = TRUE;
@@ -1401,43 +3276,43 @@
       bSumEkinhOld = TRUE;
     } else {
       if (PAR(cr)) {
-	wallcycle_start(wcycle,ewcMoveE);
-	/* Globally (over all NODEs) sum energy, virial etc. 
-	 * This includes communication 
-	 */
-	global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
-		    ir,ekind,bSumEkinhOld,constr,vcm,
-		    ir->nstlist==-1 ? &nabnsb : NULL,&chkpt,&terminate);
-	if (terminate != 0) {
-	  terminate_now = terminate;
-	  terminate = 0;
-	}
-	
-	wallcycle_stop(wcycle,ewcMoveE);
-	bSumEkinhOld = FALSE;
+        wallcycle_start(wcycle,ewcMoveE);
+        /* Globally (over all NODEs) sum energy, virial etc. 
+         * This includes communication 
+         */
+        global_stat(fplog,cr,enerd,force_vir,shake_vir,mu_tot,
+                    ir,ekind,bSumEkinhOld,constr,vcm,
+                    ir->nstlist==-1 ? &nabnsb : NULL,&chkpt,&terminate);
+        if (terminate != 0) {
+          terminate_now = terminate;
+          terminate = 0;
+        }
+        
+        wallcycle_stop(wcycle,ewcMoveE);
+        bSumEkinhOld = FALSE;
       }
 
       /* This is just for testing. Nothing is actually done to Ekin
        * since that would require extra communication.
        */
       if (!bNEMD && debug && (vcm->nr > 0)) {
-	correct_ekin(debug,mdatoms->start,mdatoms->start+mdatoms->homenr,
-		     state->v,vcm->group_p[0],
-		     mdatoms->massT,mdatoms->tmass,ekin);
+        correct_ekin(debug,mdatoms->start,mdatoms->start+mdatoms->homenr,
+                     state->v,vcm->group_p[0],
+                     mdatoms->massT,mdatoms->tmass,ekin);
       }
     
       /* Do center of mass motion removal */
       if (bStopCM && !bFFscan && !bRerunMD) {
-	check_cm_grp(fplog,vcm,1);
-	do_stopcm_grp(fplog,mdatoms->start,mdatoms->homenr,mdatoms->cVCM,
-		      state->x,state->v,vcm);
-	inc_nrnb(nrnb,eNR_STOPCM,mdatoms->homenr);
-	/*
-	  calc_vcm_grp(fplog,START(nsb),HOMENR(nsb),mdatoms->massT,x,v,vcm);
-	  check_cm_grp(fplog,vcm);
-	  do_stopcm_grp(fplog,START(nsb),HOMENR(nsb),x,v,vcm);
-	  check_cm_grp(fplog,vcm);
-	*/
+        check_cm_grp(fplog,vcm,1);
+        do_stopcm_grp(fplog,mdatoms->start,mdatoms->homenr,mdatoms->cVCM,
+                      state->x,state->v,vcm);
+        inc_nrnb(nrnb,eNR_STOPCM,mdatoms->homenr);
+        /*
+          calc_vcm_grp(fplog,START(nsb),HOMENR(nsb),mdatoms->massT,x,v,vcm);
+          check_cm_grp(fplog,vcm);
+          do_stopcm_grp(fplog,START(nsb),HOMENR(nsb),x,v,vcm);
+          check_cm_grp(fplog,vcm);
+        */
       }
       
       /* Add force and shake contribution to the virial */
@@ -1448,44 +3323,44 @@
       
       /* Sum the kinetic energies of the groups & calc temp */
       enerd->term[F_TEMP] = sum_ekin((bRerunMD && !rerun_fr.bV),
-				     &(ir->opts),ekind,ekin,
-				     &(enerd->term[F_DKDL]));
+                                     &(ir->opts),ekind,ekin,
+                                     &(enerd->term[F_DKDL]));
       enerd->term[F_EKIN] = trace(ekin);
       
       /* Calculate pressure and apply LR correction if PPPM is used.
        * Use the box from last timestep since we already called update().
        */
       enerd->term[F_PRES] =
-	calc_pres(fr->ePBC,ir->nwall,lastbox,ekin,total_vir,pres,
-		  (fr->eeltype==eelPPPM)?enerd->term[F_COUL_RECIP]:0.0);
+        calc_pres(fr->ePBC,ir->nwall,lastbox,ekin,total_vir,pres,
+                  (fr->eeltype==eelPPPM)?enerd->term[F_COUL_RECIP]:0.0);
       
       /* Calculate long range corrections to pressure and energy */
       if (bTCR || bFFscan) {
-	set_avcsixtwelve(fplog,fr,top_global);
+        set_avcsixtwelve(fplog,fr,top_global);
       }
       
       /* Calculate long range corrections to pressure and energy */
       calc_dispcorr(fplog,ir,fr,step,top_global->natoms,
-		    lastbox,state->lambda,
-		    pres,total_vir,enerd->term);
+                    lastbox,state->lambda,
+                    pres,total_vir,enerd->term);
       
       enerd->term[F_ETOT] = enerd->term[F_EPOT] + enerd->term[F_EKIN];
       
       switch (ir->etc) {
       case etcNO:
       case etcBERENDSEN:
-	break;
+        break;
       case etcNOSEHOOVER:
-	enerd->term[F_ECONSERVED] =
-	  enerd->term[F_ETOT] + nosehoover_energy(&(ir->opts),ekind,
-						  state->nosehoover_xi,
-						  state->therm_integral);
-	break;
+        enerd->term[F_ECONSERVED] =
+          enerd->term[F_ETOT] + nosehoover_energy(&(ir->opts),ekind,
+                                                  state->nosehoover_xi,
+                                                  state->therm_integral);
+        break;
       case etcVRESCALE:
-	enerd->term[F_ECONSERVED] =
-	  enerd->term[F_ETOT] + vrescale_energy(&(ir->opts),
-						state->therm_integral);
-	break;
+        enerd->term[F_ECONSERVED] =
+          enerd->term[F_ETOT] + vrescale_energy(&(ir->opts),
+                                                state->therm_integral);
+        break;
       }
       
       /* Complicated conditional when bGStatEveryStep=FALSE.
@@ -1493,39 +3368,39 @@
        * would depend on nstenergy and nstlog or step_nscheck.
        */
       if ((state->flags & (1<<estPRES_PREV)) &&
-	  (bGStatEveryStep ||
-	   (ir->nstlist > 0 && step % ir->nstlist == 0) ||
-	   (ir->nstlist < 0 && nabnsb > 0) ||
-	   (ir->nstlist == 0 && bGStat))) {
-	/* Store the pressure in t_state for pressure coupling
-	 * at the next MD step.
-	 */
-	copy_mat(pres,state->pres_prev);
+          (bGStatEveryStep ||
+           (ir->nstlist > 0 && step % ir->nstlist == 0) ||
+           (ir->nstlist < 0 && nabnsb > 0) ||
+           (ir->nstlist == 0 && bGStat))) {
+        /* Store the pressure in t_state for pressure coupling
+         * at the next MD step.
+         */
+        copy_mat(pres,state->pres_prev);
       }
 
       /* Check for excessively large energies */
       if (bIonize) {
 #ifdef GMX_DOUBLE
-	real etot_max = 1e200;
+        real etot_max = 1e200;
 #else
-	real etot_max = 1e30;
+        real etot_max = 1e30;
 #endif
-	if (fabs(enerd->term[F_ETOT]) > etot_max) {
-	  fprintf(stderr,"Energy too large (%g), giving up\n",
-		  enerd->term[F_ETOT]);
-	  break;
-	}
+        if (fabs(enerd->term[F_ETOT]) > etot_max) {
+          fprintf(stderr,"Energy too large (%g), giving up\n",
+                  enerd->term[F_ETOT]);
+          break;
+        }
       }
     }
     
     /* The coordinates (x) were unshifted in update */
     if (bFFscan && (shellfc==NULL || bConverged)) {
       if (print_forcefield(fplog,enerd->term,mdatoms->homenr,f,buf,xcopy,
-			   &(top_global->mols),mdatoms->massT,pres)) {
-	if (gmx_parallel_env)
-	  gmx_finalize(cr);
-	fprintf(stderr,"\n");
-	exit(0);
+                           &(top_global->mols),mdatoms->massT,pres)) {
+        if (gmx_parallel_env)
+          gmx_finalize(cr);
+        fprintf(stderr,"\n");
+        exit(0);
       }
     }
     
@@ -1540,11 +3415,11 @@
        * we want the new box state->box too. / EL 20040121
        */
       do_coupling(fplog,nfile,fnm,tcr,t,step,enerd->term,fr,
-		  ir,MASTER(cr),
-		  mdatoms,&(top->idef),mu_aver,
-		  top_global->mols.nr,cr,
-		  state->box,total_vir,pres,
-		  mu_tot,state->x,f,bConverged);
+                  ir,MASTER(cr),
+                  mdatoms,&(top->idef),mu_aver,
+                  top_global->mols.nr,cr,
+                  state->box,total_vir,pres,
+                  mu_tot,state->x,f,bConverged);
       debug_gmx();
     }
 
@@ -1561,52 +3436,52 @@
        * for trajectory frames).
        */
        upd_mdebin(mdebin,fp_dgdl,bGStatEveryStep && !bRerunMD,
-		 mdatoms->tmass,step_ene,t,enerd,state,lastbox,
-		 shake_vir,force_vir,total_vir,pres,
-		 ekind,mu_tot,constr);
+                 mdatoms->tmass,step_ene,t,enerd,state,lastbox,
+                 shake_vir,force_vir,total_vir,pres,
+                 ekind,mu_tot,constr);
       
       do_dr  = do_per_step(step,ir->nstdisreout);
       do_or  = do_per_step(step,ir->nstorireout);
       
       print_ebin(fp_ene,do_ene,do_dr,do_or,do_log?fplog:NULL,step,step_ene,t,
-		 eprNORMAL,bCompact,mdebin,fcd,groups,&(ir->opts));
+                 eprNORMAL,bCompact,mdebin,fcd,groups,&(ir->opts));
       
       if (ir->ePull != epullNO)
-	{
-	  pull_print_output(ir->pull,step,t);
-	}
+        {
+          pull_print_output(ir->pull,step,t);
+        }
       
       if (do_per_step(step,ir->nstlog))
-	{
-		if(fflush(fplog) != 0)
-		{
-			gmx_fatal(FARGS,"Cannot flush logfile - maybe you are out of quota?");
-		}
-	}
+        {
+                if(fflush(fplog) != 0)
+                {
+                        gmx_fatal(FARGS,"Cannot flush logfile - maybe you are out of quota?");
+                }
+        }
     }
     
     
     /* Remaining runtime */
     if (MULTIMASTER(cr) && do_verbose) {
       if (shellfc)
-	fprintf(stderr,"\n");
+        fprintf(stderr,"\n");
       print_time(stderr,start_t,step,ir);
     }
 
     /* Replica exchange */
     bExchanged = FALSE;
     if ((repl_ex_nst > 0) && (step > 0) && !bLastStep &&
-	do_per_step(step,repl_ex_nst))
+        do_per_step(step,repl_ex_nst))
       bExchanged = replica_exchange(fplog,cr,repl_ex,state_global,enerd->term,
-				    state,step,t);
+                                    state,step,t);
     if (bExchanged && PAR(cr)) {
       if (DOMAINDECOMP(cr)) {
-	dd_partition_system(fplog,step,cr,TRUE,
-			    state_global,top_global,ir,
-			    state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
-			    nrnb,wcycle,FALSE);
+        dd_partition_system(fplog,step,cr,TRUE,
+                            state_global,top_global,ir,
+                            state,&f,&buf,mdatoms,top,fr,vsite,shellfc,constr,
+                            nrnb,wcycle,FALSE);
       } else {
-	bcast_state(cr,state,FALSE);
+        bcast_state(cr,state,FALSE);
       }
     }
     
@@ -1636,13 +3511,13 @@
     /* Tell the PME only node to finish */
     gmx_pme_finish(cr);
   }
-	  
+        
   if (MASTER(cr)) {
     if (bGStatEveryStep && !bRerunMD) {
       print_ebin(fp_ene,FALSE,FALSE,FALSE,fplog,step,step_ene,t,
-		 eprAVER,FALSE,mdebin,fcd,groups,&(ir->opts));
+                 eprAVER,FALSE,mdebin,fcd,groups,&(ir->opts));
       print_ebin(fp_ene,FALSE,FALSE,FALSE,fplog,step,step_ene,t,
-		 eprRMS,FALSE,mdebin,fcd,groups,&(ir->opts));
+                 eprRMS,FALSE,mdebin,fcd,groups,&(ir->opts));
     }
     close_enx(fp_ene);
     if (ir->nstxtcout)
@@ -1662,9 +3537,9 @@
 
   if (shellfc && fplog) {
     fprintf(fplog,"Fraction of iterations that converged:           %.2f %%\n",
-	    (nconverged*100.0)/step_rel);
+            (nconverged*100.0)/step_rel);
     fprintf(fplog,"Average number of force evaluations per MD step: %.2f\n\n",
-	    tcount/step_rel);
+            tcount/step_rel);
   }
 
   if (repl_ex_nst > 0 && MASTER(cr)) {
@@ -1672,6 +3547,42 @@
   }
 
   *nsteps_done = step_rel;
-    
+
+//clear memory and reset variables
+  gmx_mtop_clear_local_top(top);
+
+  clear_ekindata(ekind);
+
+  clear_enerdata(enerd);
+
+  clear_state(state);
+
+  clear_vcm(vcm);
+
+  clear_graph(graph);
+
+  reset_energy_history(state_global);
+
+  reset_kinetic_energy_history(state_global);
+
+  state_global->ekinstate.bUpToDate = FALSE;
+  
+  clear_sd(sd,ir);
+
+//reset_forces
+  for(i=0;i<top_global->natoms;i++)
+  {
+      f[i][XX] = 0.0;
+      f[i][YY] = 0.0;
+      f[i][ZZ] = 0.0;
+  }
+//reset buf
+  for(i=0;i<top_global->natoms;i++)
+  {
+      buf[i][XX] = 0.0;
+      buf[i][YY] = 0.0;
+      buf[i][ZZ] = 0.0;
+  }
+  
   return start_t;
 }
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/kernel/mdrun.c ./src/kernel/mdrun.c
--- ../gromacs-4.0.7-git//src/kernel/mdrun.c	2011-09-18 18:17:05.845041497 +0200
+++ ./src/kernel/mdrun.c	2011-09-18 12:53:13.015035929 +0200
@@ -387,6 +387,25 @@
   FILE     *fplog,*fptest;
   int      sim_part;
   char     suffix[STRLEN];
+  // for testing:
+  int      i;
+
+  
+//needed variables for calling mdrunner in split-up mode:
+  time_t        start_t;
+  mdrunner_comm  mc;
+  mc.state       = NULL;
+  mc.buf         = NULL;
+  mc.f           = NULL;
+  mc.mtop        = NULL;
+  mc.mdatoms     = NULL;
+  mc.fr          = NULL;
+  mc.fcd         = NULL;
+  mc.ewaldcoeff  = 0;
+  mc.pmedata     = NULL;
+  mc.vsite       = NULL;
+  mc.nsteps_done = 0;
+  mc.mdebin      = NULL;
 	
   cr = init_par(&argc,&argv);
 
@@ -493,12 +512,50 @@
   ddxyz[YY] = (int)(realddxyz[YY] + 0.5);
   ddxyz[ZZ] = (int)(realddxyz[ZZ] + 0.5);
   
-  mdrunner(fplog,cr,NFILE,fnm,bVerbose,bCompact,
-	   ddxyz,dd_node_order,rdd,rconstr,
-	   dddlb_opt[0],dlb_scale,ddcsx,ddcsy,ddcsz,
-	   nstepout,ed,repl_ex_nst,repl_ex_seed,pforce,
-	   cpt_period,max_hours,Flags);
-  
+//   mdrunner(fplog,cr,NFILE,fnm,bVerbose,bCompact,
+// 	   ddxyz,dd_node_order,rdd,rconstr,
+// 	   dddlb_opt[0],dlb_scale,ddcsx,ddcsy,ddcsz,
+// 	   nstepout,ed,repl_ex_nst,repl_ex_seed,pforce,
+// 	   cpt_period,max_hours,Flags);
+
+
+//call mdrunner in split-up mode:
+  mdrunner_initialize(fplog,cr,NFILE,fnm,
+		      bVerbose,
+		      ddxyz,dd_node_order,rdd,rconstr,
+		      dddlb_opt[0],dlb_scale,
+		      ddcsx,ddcsy,ddcsz,
+		      pforce,Flags,
+		      &mc);
+  start_t = mdrunner_integrate(fplog,cr,NFILE,fnm,
+			       bVerbose,bCompact,
+			       dlb_scale,
+			       nstepout,ed,repl_ex_nst,repl_ex_seed,
+			       cpt_period,max_hours,Flags,
+			       &mc);
+  clear_mdebin(mc.mdebin);
+//   start_t = mdrunner_integrate(fplog,cr,NFILE,fnm,
+//                                bVerbose,bCompact,
+//                                dlb_scale,
+//                                nstepout,ed,repl_ex_nst,repl_ex_seed,
+//                                cpt_period,max_hours,Flags,
+//                                &mc);
+//   clear_mdebin(mc.mdebin);
+//   mc.inputrec->bContinuation=TRUE;
+//   for(i=1;i<10000;i++) {
+//     system("rm ener.edr traj.trr traj.xtc confout.gro");
+//     start_t = mdrunner_integrate(fplog,cr,NFILE,fnm,
+// 				 bVerbose,bCompact,
+// 				 dlb_scale,
+// 				 nstepout,ed,repl_ex_nst,repl_ex_seed,
+// 				 cpt_period,max_hours,Flags,
+// 				 &mc);
+//     clear_mdebin(mc.mdebin);
+//   }
+  mdrunner_finalize(fplog,cr,NFILE,fnm,
+		    Flags,
+		    start_t,&mc);
+
   if (gmx_parallel_env)
     gmx_finalize(cr);
 
@@ -515,3 +572,249 @@
   return 0;
 }
 
+bool copy_and_add_molecule(mdrunner_comm *mccurrent,
+                           mdrunner_comm *mctrial,
+                           int nmolcurrent,
+                           int nmoltrial,
+                           rvec *xadd,
+                           rvec *vadd,
+                           int *atomtype,
+                           int natomspertrialmolecule,
+                           int index_offset,
+                           real *sigmasatomcrossterms2frac,
+                           int natomtypes)
+{
+    bool bAccept = TRUE;
+    int i,j,k,l,index,idx,start;
+    int imoltype,atomtype_index;
+    real dx,dy,dz,dr2,hbx,hby,hbz;
+    
+    hbx = 0.5*mccurrent->box[XX][XX];
+    hby = 0.5*mccurrent->box[YY][YY];
+    hbz = 0.5*mccurrent->box[ZZ][ZZ];
+        
+    index = 0;
+    for(i=0;i<mccurrent->mtop->nmolblock;i++)
+    {
+        imoltype = mccurrent->mtop->molblock[i].type;
+        for(j=0;j<mccurrent->mtop->molblock[i].nmol;j++)
+        {
+            for(k=0;k<mccurrent->mtop->moltype[imoltype].atoms.nr;k++)
+            {
+                mctrial->state->x[index][XX] = mccurrent->state->x[index][XX];
+                mctrial->state->x[index][YY] = mccurrent->state->x[index][YY];
+                mctrial->state->x[index][ZZ] = mccurrent->state->x[index][ZZ];
+                atomtype_index = mccurrent->mtop->moltype[imoltype].atoms.atom[k].type;
+                for(l=0;l<natomspertrialmolecule;l++)
+                {
+                    dx   = (xadd[l][XX]-mctrial->state->x[index][XX]);
+                    dy   = (xadd[l][YY]-mctrial->state->x[index][YY]);
+                    dz   = (xadd[l][ZZ]-mctrial->state->x[index][ZZ]);
+                    if(dx>hbx)
+                        dx -= mccurrent->box[XX][XX];
+                    else if(dx<-hbx)
+                        dx += mccurrent->box[XX][XX];
+                    if(dy>hby)
+                        dy -= mccurrent->box[YY][YY];
+                    else if(dy<-hby)
+                        dy += mccurrent->box[YY][YY];
+                    if(dz>hbz)
+                        dz -= mccurrent->box[ZZ][ZZ];
+                    else if(dx<-hbz)
+                        dz += mccurrent->box[ZZ][ZZ];
+                    dr2  = dx*dx + dy*dy + dz*dz;
+                    idx  = atomtype[l]*natomtypes + atomtype_index;
+                    if(dr2<=sigmasatomcrossterms2frac[idx]) //some percentage % of sigma cross-terms of interacting atoms
+                    {
+                        bAccept = FALSE;
+                        return bAccept;
+                    }
+                }
+                mctrial->state->v[index][XX] = mccurrent->state->v[index][XX];
+                mctrial->state->v[index][YY] = mccurrent->state->v[index][YY];
+                mctrial->state->v[index][ZZ] = mccurrent->state->v[index][ZZ];
+                index++;
+            }
+        }
+    }
+
+    start = nmolcurrent*natomspertrialmolecule;
+    for(l=0;l<natomspertrialmolecule;l++)
+    {
+        mctrial->state->x[index_offset+start+l][XX] = xadd[l][XX];
+        mctrial->state->x[index_offset+start+l][YY] = xadd[l][YY];
+        mctrial->state->x[index_offset+start+l][ZZ] = xadd[l][ZZ];
+        mctrial->state->v[index_offset+start+l][XX] = vadd[l][XX];
+        mctrial->state->v[index_offset+start+l][YY] = vadd[l][YY];
+        mctrial->state->v[index_offset+start+l][ZZ] = vadd[l][ZZ];
+    }
+    
+    return bAccept;
+}
+
+void copy_and_remove_molecule(mdrunner_comm *mccurrent,
+                              mdrunner_comm *mctrial,
+                              int nmolcurrent,
+                              int nmoltrial,
+                              int imolremove,
+                              int index_offset,
+                              int natomspertrialmolecule)
+{
+    int i;
+
+    for(i=index_offset;i<imolremove*natomspertrialmolecule;i++)
+    {
+        mctrial->state->x[i][XX] = mccurrent->state->x[i][XX];
+        mctrial->state->x[i][YY] = mccurrent->state->x[i][YY];
+        mctrial->state->x[i][ZZ] = mccurrent->state->x[i][ZZ];
+        mctrial->state->v[i][XX] = mccurrent->state->v[i][XX];
+        mctrial->state->v[i][YY] = mccurrent->state->v[i][YY];
+        mctrial->state->v[i][ZZ] = mccurrent->state->v[i][ZZ];
+    }
+    for(i=index_offset+(imolremove+1)*natomspertrialmolecule;i<nmolcurrent*natomspertrialmolecule;i++)
+    {
+        mctrial->state->x[i-natomspertrialmolecule][XX] = mccurrent->state->x[i][XX];
+        mctrial->state->x[i-natomspertrialmolecule][YY] = mccurrent->state->x[i][YY];
+        mctrial->state->x[i-natomspertrialmolecule][ZZ] = mccurrent->state->x[i][ZZ];
+        mctrial->state->v[i-natomspertrialmolecule][XX] = mccurrent->state->v[i][XX];
+        mctrial->state->v[i-natomspertrialmolecule][YY] = mccurrent->state->v[i][YY];
+        mctrial->state->v[i-natomspertrialmolecule][ZZ] = mccurrent->state->v[i][ZZ];
+    }
+    
+    return;
+}
+
+void clear_xsave(mdrunner_comm *mc)
+{
+    sfree(mc->xsave);
+    mc->xsave = NULL;
+}
+
+void clear_vsave(mdrunner_comm *mc)
+{
+    sfree(mc->vsave);
+    mc->vsave = NULL;
+}
+
+void copy_saved_coords_and_velocities(mdrunner_comm *mc)
+{
+    int i;
+
+    for(i=0;i<mc->state->natoms;i++)
+    {
+        mc->state->x[i][XX] = mc->xsave[i][XX];
+        mc->state->x[i][YY] = mc->xsave[i][YY];
+        mc->state->x[i][ZZ] = mc->xsave[i][ZZ];
+        mc->state->v[i][XX] = mc->vsave[i][XX];
+        mc->state->v[i][YY] = mc->vsave[i][YY];
+        mc->state->v[i][ZZ] = mc->vsave[i][ZZ];
+    }
+
+    clear_xsave(mc);
+    clear_vsave(mc);
+    
+    return;
+}
+
+void swap_coordinate_indices(mdrunner_comm *mc,
+                             int molblock,
+                             int curr_mol,
+                             int trial_mol)
+{
+    int i;
+    int NAtomsMol;
+    rvec *xCurr;
+    rvec *vCurr;
+
+    if(curr_mol==1)
+    {
+        return;
+    }
+    
+    NAtomsMol = mc->mtop->molblock[molblock].natoms_mol;
+    snew(xCurr,NAtomsMol);
+    snew(vCurr,NAtomsMol);
+    for(i=0;i<NAtomsMol;i++)
+    {
+        xCurr[i][XX] = mc->state->x[curr_mol*NAtomsMol+i][XX];
+        xCurr[i][YY] = mc->state->x[curr_mol*NAtomsMol+i][YY];
+        xCurr[i][ZZ] = mc->state->x[curr_mol*NAtomsMol+i][ZZ];
+        vCurr[i][XX] = mc->state->v[curr_mol*NAtomsMol+i][XX];
+        vCurr[i][YY] = mc->state->v[curr_mol*NAtomsMol+i][YY];
+        vCurr[i][ZZ] = mc->state->v[curr_mol*NAtomsMol+i][ZZ];
+
+        mc->state->x[curr_mol*NAtomsMol+i][XX] = mc->state->x[trial_mol*NAtomsMol+i][XX];
+        mc->state->x[curr_mol*NAtomsMol+i][YY] = mc->state->x[trial_mol*NAtomsMol+i][YY];
+        mc->state->x[curr_mol*NAtomsMol+i][ZZ] = mc->state->x[trial_mol*NAtomsMol+i][ZZ];
+        mc->state->v[curr_mol*NAtomsMol+i][XX] = mc->state->v[trial_mol*NAtomsMol+i][XX];
+        mc->state->v[curr_mol*NAtomsMol+i][YY] = mc->state->v[trial_mol*NAtomsMol+i][YY];
+        mc->state->v[curr_mol*NAtomsMol+i][ZZ] = mc->state->v[trial_mol*NAtomsMol+i][ZZ];
+        
+        mc->state->x[trial_mol*NAtomsMol+i][XX] = xCurr[i][XX];
+        mc->state->x[trial_mol*NAtomsMol+i][YY] = xCurr[i][YY];
+        mc->state->x[trial_mol*NAtomsMol+i][ZZ] = xCurr[i][ZZ];
+        mc->state->v[trial_mol*NAtomsMol+i][XX] = vCurr[i][XX];
+        mc->state->v[trial_mol*NAtomsMol+i][YY] = vCurr[i][YY];
+        mc->state->v[trial_mol*NAtomsMol+i][ZZ] = vCurr[i][ZZ];
+    }
+    sfree(xCurr);
+    xCurr = NULL;
+    sfree(vCurr);
+    vCurr = NULL;
+    
+    return;
+}
+
+extern void clear_state(t_state *state)
+{
+  if (state->nrngi > 1)
+  {
+      if (state->flags & (1<<estLD_RNG))
+      {
+          sfree(state->ld_rng);
+      }
+      if (state->flags & (1<<estLD_RNGI))
+      {
+          sfree(state->ld_rngi);
+      }
+  }
+  sfree(state);
+}
+
+void reset_energy_history(t_state *state)
+{
+  int i;
+  
+  for(i=0;i<state->enerhist.nener;i++)
+  {
+      state->enerhist.ener_ave[i] = 0.0;
+      state->enerhist.ener_sum[i] = 0.0;
+  }
+  
+  sfree(state->enerhist.ener_ave);
+  state->enerhist.ener_ave = NULL;
+  sfree(state->enerhist.ener_sum);
+  state->enerhist.ener_sum = NULL;
+  state->enerhist.nener = 0;
+}
+
+void reset_kinetic_energy_history(t_state *state)
+{
+  int i;
+
+  for(i=0;i<state->ekinstate.ekinh_n;i++)
+  {
+      state->ekinstate.ekinh[i][0][0] = 0.0;
+      state->ekinstate.ekinh[i][0][1] = 0.0;
+      state->ekinstate.ekinh[i][0][2] = 0.0;
+      state->ekinstate.ekinh[i][1][0] = 0.0;
+      state->ekinstate.ekinh[i][1][1] = 0.0;
+      state->ekinstate.ekinh[i][1][2] = 0.0;
+      state->ekinstate.ekinh[i][2][0] = 0.0;
+      state->ekinstate.ekinh[i][2][1] = 0.0;
+      state->ekinstate.ekinh[i][2][2] = 0.0;
+  }
+
+  state->ekinstate.dekindl  = 0.0;
+  state->ekinstate.mvcos    = 0.0;
+}
\ Kein Zeilenumbruch am Dateiende.
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/mdlib/constr.c ./src/mdlib/constr.c
--- ../gromacs-4.0.7-git//src/mdlib/constr.c	2011-09-18 18:17:05.845041497 +0200
+++ ./src/mdlib/constr.c	2011-09-18 12:53:13.025035929 +0200
@@ -926,3 +926,9 @@
 
   return bInterCG;
 }
+
+void clear_constr(gmx_constr_t constr)
+{
+    sfree(constr);
+    constr = NULL;
+}
\ Kein Zeilenumbruch am Dateiende.
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/mdlib/force.c ./src/mdlib/force.c
--- ../gromacs-4.0.7-git//src/mdlib/force.c	2011-09-18 18:17:05.855041497 +0200
+++ ./src/mdlib/force.c	2011-09-18 12:53:13.025035929 +0200
@@ -78,6 +78,29 @@
   return fr;
 }
 
+void clear_forcerec(t_forcerec *fr)
+{
+  sfree(fr->phi);        
+  sfree(fr->cginfo_global);
+//   sfree(fr->cginfo);
+//   sfree(fr->cg_cm);
+  sfree(fr->shift_vec);
+  sfree(fr->gid2nblists);
+  sfree(fr->nblists);
+  sfree(fr->wall_tab);
+  sfree(fr->f_twin);
+  sfree(fr->fshift_twin);
+  sfree(fr->f_novirsum);
+  sfree(fr->pmedata);
+  sfree(fr->fshift);
+  sfree(fr->nbfp);
+  sfree(fr->egp_flags);
+  sfree(fr->atype_radius);
+  sfree(fr->atype_vol);
+  sfree(fr->atype_surftens);
+  sfree(fr->qr);
+}
+
 #ifdef DEBUG
 static void pr_nbfp(FILE *fp,real *nbfp,bool bBHAM,int atnr)
 {
@@ -1853,3 +1876,14 @@
     }
 }
 
+void clear_enerdata(gmx_enerdata_t *enerd)
+{
+  int i;
+  
+  for(i=0;i<egNR;i++)
+  {
+      sfree(enerd->grpp.ener[i]);
+  }
+  
+  sfree(enerd);
+}
\ Kein Zeilenumbruch am Dateiende.
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/mdlib/mdebin.c ./src/mdlib/mdebin.c
--- ../gromacs-4.0.7-git//src/mdlib/mdebin.c	2011-09-18 18:17:05.865041497 +0200
+++ ./src/mdlib/mdebin.c	2011-09-18 12:53:13.025035929 +0200
@@ -127,6 +127,7 @@
   int      i,j,ni,nj,n,k,kk,ncon,nset;
   bool     bBHAM,b14;
   
+  f_nre  = 0; // otherwise, multiple calls to mdrunner_integrate are not possible!NnCrmsd; 
   groups = &mtop->groups;
 
   bBHAM = (mtop->ffparams.functype[0] == F_BHAM);
@@ -300,6 +301,7 @@
     grpnms[i]=strdup(buf);
   }
   md->itemp=get_ebin_space(md->ebin,md->nTC,grpnms);
+  sfree(*grpnms);
   if (etc == etcNOSEHOOVER) {
     for(i=0; (i<md->nTC); i++) {
       ni=groups->grps[egcTC].nm_ind[i];
@@ -307,6 +309,7 @@
       grpnms[i]=strdup(buf);
     }
     md->itc=get_ebin_space(md->ebin,md->nTC,grpnms);
+    sfree(*grpnms);
   } else  if (etc == etcBERENDSEN || etc == etcYES || etc == etcVRESCALE) {
     for(i=0; (i<md->nTC); i++) {
       ni=groups->grps[egcTC].nm_ind[i];
@@ -314,6 +317,7 @@
       grpnms[i]=strdup(buf);
     }
     md->itc=get_ebin_space(md->ebin,md->nTC,grpnms);
+    sfree(*grpnms);
   }
   sfree(grpnms);
   
@@ -330,12 +334,13 @@
       grpnms[3*i+ZZ]=strdup(buf);
     }
     md->iu=get_ebin_space(md->ebin,3*md->nU,grpnms);
+    sfree(*grpnms);
     sfree(grpnms);
   }
-  
+
   if (fp_ene != -1)
     do_enxnms(fp_ene,&md->ebin->nener,&md->ebin->enm);
-    
+  
   return md;
 }
 
@@ -702,4 +707,18 @@
 	}
 }
 
-
+void clear_mdebin(t_mdebin *mdebin)
+{
+    int i;
+    
+    for(i=0;i<mdebin->ebin->nener;i++)
+    {
+        sfree(mdebin->ebin->enm[i]);
+    }
+    sfree(mdebin->ebin->enm);
+    sfree(mdebin->ebin->e);
+    sfree(mdebin->ebin);
+    sfree(mdebin->igrp);
+    sfree(mdebin);
+    mdebin = NULL;
+}
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/mdlib/sim_util.c ./src/mdlib/sim_util.c
--- ../gromacs-4.0.7-git//src/mdlib/sim_util.c	2011-09-18 18:17:05.865041497 +0200
+++ ./src/mdlib/sim_util.c	2011-09-18 12:53:13.025035929 +0200
@@ -1039,6 +1039,99 @@
   }
 }
 
+void calc_dispcorr_non_static(FILE *fplog,t_inputrec *ir,t_forcerec *fr,int step,
+                              int natoms,matrix box,real lambda,
+                              tensor pres,tensor virial,real ener[])
+{
+  bool bFirst;
+  bool bCorrAll,bCorrPres;
+  real dvdlambda,invvol,dens,ninter,avcsix,avctwelve,enerdiff,svir=0,spres=0;
+  int  m;
+
+  bFirst = TRUE;
+  ener[F_DISPCORR] = 0.0;
+
+  if (ir->eDispCorr != edispcNO) {
+    bCorrAll  = (ir->eDispCorr == edispcAllEner ||
+                 ir->eDispCorr == edispcAllEnerPres);
+    bCorrPres = (ir->eDispCorr == edispcEnerPres ||
+                 ir->eDispCorr == edispcAllEnerPres);
+
+    if (bFirst)
+      calc_enervirdiff(fplog,ir->eDispCorr,fr);
+    
+    invvol = 1/det(box);
+    if (fr->n_tpi) {
+      /* Only correct for the interactions with the inserted molecule */
+      dens = (natoms - fr->n_tpi)*invvol;
+      ninter = fr->n_tpi;
+    } else {
+      dens = natoms*invvol;
+      ninter = 0.5*natoms;
+    }
+
+    if (ir->efep == efepNO) {
+      avcsix    = fr->avcsix[0];
+      avctwelve = fr->avctwelve[0];
+    } else {
+      avcsix    = (1 - lambda)*fr->avcsix[0]    + lambda*fr->avcsix[1];
+      avctwelve = (1 - lambda)*fr->avctwelve[0] + lambda*fr->avctwelve[1];
+    }
+    
+    enerdiff = ninter*(dens*fr->enerdiffsix - fr->enershiftsix);
+    ener[F_DISPCORR] += avcsix*enerdiff;
+    dvdlambda = 0.0;
+    if (ir->efep != efepNO)
+      dvdlambda += (fr->avcsix[1] - fr->avcsix[0])*enerdiff;
+
+    if (bCorrAll) {
+      enerdiff = ninter*(dens*fr->enerdifftwelve - fr->enershifttwelve);
+      ener[F_DISPCORR] += avctwelve*enerdiff;
+      if (fr->efep != efepNO)
+        dvdlambda += (fr->avctwelve[1] - fr->avctwelve[0])*enerdiff;
+    }
+
+    if (bCorrPres) {
+      svir = ninter*dens*avcsix*fr->virdiffsix/3.0;
+      if (ir->eDispCorr == edispcAllEnerPres)
+        svir += ninter*dens*avctwelve*fr->virdifftwelve/3.0;
+      
+      /* The factor 2 is because of the Gromacs virial definition */
+      spres = -2.0*invvol*svir*PRESFAC;
+      
+      for(m=0; m<DIM; m++) {
+        virial[m][m] += svir;
+        pres[m][m] += spres;
+      }
+      ener[F_PRES] += spres;
+    }
+    
+    if (bFirst && fplog) {
+      if (bCorrAll)
+        fprintf(fplog,"Long Range LJ corr.: <C6> %10.4e, <C12> %10.4e\n",
+                avcsix,avctwelve);
+      else
+        fprintf(fplog,"Long Range LJ corr.: <C6> %10.4e\n",avcsix);
+      
+      if (bCorrPres)
+        fprintf(fplog,
+                "Long Range LJ corr.: Epot %10g, Pres: %10g, Vir: %10g\n",
+                ener[F_DISPCORR],spres,svir);
+      else
+        fprintf(fplog,"Long Range LJ corr.: Epot %10g\n",ener[F_DISPCORR]);
+    }
+    bFirst = FALSE;
+
+    if (fr->bSepDVDL && do_per_step(step,ir->nstlog))
+      fprintf(fplog,sepdvdlformat,"Dispersion correction",
+              ener[F_DISPCORR],dvdlambda);
+    
+    ener[F_EPOT] += ener[F_DISPCORR];
+    if (fr->efep != efepNO)
+      ener[F_DVDL] += dvdlambda;
+  }
+}
+
 
 void do_pbc_first(FILE *fplog,matrix box,t_forcerec *fr,
 		  t_graph *graph,rvec x[])
@@ -1223,7 +1316,7 @@
   char filemode[2];
 
   sprintf(filemode, (Flags & MD_APPENDFILES) ? "a" : "w");
-	
+
   /* Initial values */
   *t = *t0       = ir->init_t;
   if (ir->efep != efepNO) {
@@ -1243,7 +1336,7 @@
   if (*bSimAnn) {
     update_annealing_target_temp(&(ir->opts),ir->init_t);
   }
-
+  
   *bNEMD = (ir->opts.ngacc > 1) || (norm(ir->opts.acc[0]) > 0);
   
   if (sd && (ir->eI == eiBD || EI_SD(ir->eI) || ir->etc == etcVRESCALE)) {
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/mdlib/tgroup.c ./src/mdlib/tgroup.c
--- ../gromacs-4.0.7-git//src/mdlib/tgroup.c	2011-09-18 18:17:05.865041497 +0200
+++ ./src/mdlib/tgroup.c	2011-09-18 12:53:13.025035929 +0200
@@ -247,3 +247,11 @@
 
   return T;
 }
+
+void clear_ekindata(gmx_ekindata_t *ekind)
+{
+  sfree(ekind->tcstat);
+  sfree(ekind->grpstat);
+  sfree(ekind);
+  ekind = NULL;
+}
\ Kein Zeilenumbruch am Dateiende.
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/mdlib/update.c ./src/mdlib/update.c
--- ../gromacs-4.0.7-git//src/mdlib/update.c	2011-09-18 18:17:05.875041497 +0200
+++ ./src/mdlib/update.c	2011-09-18 12:53:13.025035929 +0200
@@ -314,6 +314,37 @@
   return sd;
 }
 
+void clear_sd(gmx_stochd_t sd,t_inputrec *ir)
+{
+    int i;
+
+    if(sd)
+    {
+        if (ir->eI == eiBD)
+        {
+            sfree(sd->bd_rf);
+        }
+        else if (EI_SD(ir->eI))
+        {
+            sfree(sd->sdc);
+            sfree(sd->sdsig);
+            if(sd->sd_V)
+            {
+                for(i=0;i<sd->sd_V_nalloc;i++)
+                {
+                    sfree(sd->sd_V[i]);
+                }
+            }
+        }
+
+        sfree(sd->gaussrand);
+        sfree(sd);
+        sd=NULL;
+    }
+
+    return;
+}
+
 void get_stochd_state(t_gmx_stochd *sd,t_state *state)
 {
   gmx_rng_get_state(sd->gaussrand,state->ld_rng,state->ld_rngi);
diff -ur -x '^.git' ../gromacs-4.0.7-git//src/mdlib/vcm.c ./src/mdlib/vcm.c
--- ../gromacs-4.0.7-git//src/mdlib/vcm.c	2011-09-18 18:17:05.875041497 +0200
+++ ./src/mdlib/vcm.c	2011-09-18 12:53:13.025035929 +0200
@@ -95,6 +95,20 @@
   return vcm;
 }
 
+void clear_vcm(t_vcm *vcm)
+{
+  sfree(vcm->group_ndf);
+  sfree(vcm->group_p);
+  sfree(vcm->group_v);
+  sfree(vcm->group_x);
+  sfree(vcm->group_j);
+  sfree(vcm->group_w);
+  sfree(vcm->group_i);
+  sfree(vcm->group_mass);
+  sfree(vcm->group_name);
+  sfree(vcm);
+}
+
 static void update_tensor(rvec x,real m0,tensor I)
 {
   real xy,xz,yz;
